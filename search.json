[{"title":"Redux中Action和Reducer的编写","url":"/2021/04/07/10.Redux%E4%B8%ADAction%E5%92%8CReducer%E7%9A%84%E7%BC%96%E5%86%99/","content":"前端——Redux中Action和Reducer的编写上一篇文章中创建了Store和Reducer，能够使组件获取到Store中的数据。\n现在来看如何改变Store中的数据。\n\n依然是回顾一下Redux的工作流程。\ncomponent需要告诉Store：我要获取数据，这就需要创建一个action。\n实现Todo List输入框的功能\n回想一下todolist的功能，在输入框中输入内容，输入框中的内容也需要跟着变化，这就需要与store做通信。当input框中的内容发生改变时，就改变store中对应的数据。\n首先在input组件上绑定一个handleInputChange事件。别忘记在constructor中修改这个方法的this指向。\n然后在这个方法中定义action，来和store进行通信。\n在React中，一个action的写法有一定的规范。首先，action是一个对象，需要有type属性，这个属性的内容是对这个action的一些描述。value属性代表要传给store的值。\nconst action = &#123;  type: &quot;change_input_value&quot;,  value: e.target.value,&#125;;\n\n现在创建了action，想要把这个action传递给store。\nstore提供了一个方法dispatch()，调用store.dispatch(action)即可把action传递给store。\nhandleInputChange(e) &#123;  const action = &#123;    type: &quot;change_input_value&quot;,    value: e.target.value,  &#125;;  store.dispatch(action);&#125;\n\n现在就把action传递给了store。传是传过去了，可是store不知道该怎么处理这个action。store要去在reducer中去查找数据。\nstore要做的操作就是，把当前的数据和接收到的action一起转发给reducer，然后由reducer告诉store需要做什么。\n有一个好消息是，Redux中的store会自动帮我们转发当前的state和接收到的action。也就是说，只要store一接收到action，就会自动将当前state和这个action转发给reducer。\n这样的话，reducer就会接收到两个参数：state和action。分别对应上一次在store中存储的数据（修改之前的）和用户传递的action。\n现在工作就交给了reducer。reducer需要根据传递过来的state和action，将二者结合，做一些处理，来告诉store，新的数据会变成什么样子。\nconst defaultState = &#123;  inputValue: &quot;store&quot;,  list: [],&#125;;// reducer可以接收state，但是绝不能修改state// state: Store中上一次存储的数据// action: 用户传递的actionexport default (state = defaultState, action) =&gt; &#123;  if (action.type === &quot;change_input_value&quot;) &#123;    // 对state进行一次深拷贝    const newState = JSON.parse(JSON.stringify(state));    // 修改input框中value的值    newState.inputValue = action.value;    return newState;  &#125;  return state;&#125;;\n\n这里要注意，reducer有一个限制，那就是reducer可以接收state，但是绝不能修改state。这也是为什么接收到state之后要进行深拷贝，用来拿到一个新的newState。\n对newState进行修改之后，将其return。这个newState就被return给了store。store会自动将原来的state替换为newState，此时的state就被更新了。\n此时组件中显示的数据应该同步被更新，但是Redux并不会自动去做这件事情。我们需要手动处理这个问题。\n在对应的组件中，找到constructor构造函数，在其中添加以下一行代码：\nstore.subscribe(this.handleStoreChange);\n\n这行代码表示，当前组件订阅了store。也就是说，只要store中的数据发生了改变，subscribe()中的函数就会自动被执行。\n此时只要手动更新当前组件的state即可，即重新取一次store中的数据，然后调用setState()替换掉当前组件的state。\nhandleStoreChange() &#123;  this.setState(store.getState());&#125;\n\n实现Todo List列表展示的功能当点击页面的提交按钮的时候，应该把当前输入框中的内容添加到store中的list数组中。\n首先，需要给button绑定一个点击事件。别忘记绑定this作用域。\nrender() &#123;  return (    &lt;div style=&#123;&#123; margin: &quot;20px auto&quot;, width: &quot;500px&quot; &#125;&#125;&gt;      &lt;Input        value=&#123;this.state.inputValue&#125;        placeholder=&quot;todo info&quot;        style=&#123;&#123; width: &quot;430px&quot; &#125;&#125;        onChange=&#123;this.handleInputChange&#125;      /&gt;      &lt;Button type=&quot;primary&quot; onClick=&#123;this.handleBtnClick&#125;&gt;        提交      &lt;/Button&gt;      &lt;Divider orientation=&quot;left&quot;&gt;Todo List&lt;/Divider&gt;      &lt;List        size=&quot;large&quot;        bordered        dataSource=&#123;this.state.list&#125;        renderItem=&#123;(item) =&gt; &lt;List.Item&gt;&#123;item&#125;&lt;/List.Item&gt;&#125;      /&gt;    &lt;/div&gt;  );&#125;\n\n现在来实现handleBtnClick\nhandleBtnClick() &#123;  const action = &#123;    type: &quot;add_list_item&quot;,    value: store.getState().inputValue,  &#125;;  store.dispatch(action);&#125;\n\n此时在reducer中添加add_list_item对应的action的操作\nif (action.type === &quot;add_list_item&quot;) &#123;  const newState = JSON.parse(JSON.stringify(state));  newState.list.push(newState.inputValue);  newState.inputValue = &quot;&quot;;  return newState;&#125;\n\n实现删除Todo List列表项的功能同样的，在列表项item上绑定点击事件，同时传递item对应的index值。\nrender() &#123;  return (    &lt;div style=&#123;&#123; margin: &quot;20px auto&quot;, width: &quot;500px&quot; &#125;&#125;&gt;      &lt;Input        value=&#123;this.state.inputValue&#125;        placeholder=&quot;todo info&quot;        style=&#123;&#123; width: &quot;430px&quot; &#125;&#125;        onChange=&#123;this.handleInputChange&#125;      /&gt;      &lt;Button type=&quot;primary&quot; onClick=&#123;this.handleBtnClick&#125;&gt;        提交      &lt;/Button&gt;      &lt;Divider orientation=&quot;left&quot;&gt;Todo List&lt;/Divider&gt;      &lt;List        size=&quot;large&quot;        bordered        dataSource=&#123;this.state.list&#125;        renderItem=&#123;(item, index) =&gt; (          &lt;List.Item onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;            &#123;item&#125;          &lt;/List.Item&gt;        )&#125;      /&gt;    &lt;/div&gt;  );&#125;\n\n实现handleItemClick\nhandleItemClick(index) &#123;  const action = &#123;    type: &quot;delete_list_item&quot;,    index: index,  &#125;;  store.dispatch(action);&#125;\n\n在reducer中实现这个action对应的功能。\nif (action.type === &quot;delete_list_item&quot;) &#123;  const newState = JSON.parse(JSON.stringify(state));  newState.list.splice(action.index, 1);  return newState;&#125;\n\n完整代码public/index.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;    &lt;title&gt;Todo List&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\nsrc/index.js\nimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import TodoList from &quot;./TodoList&quot;;ReactDOM.render(  &lt;React.StrictMode&gt;    &lt;TodoList /&gt;  &lt;/React.StrictMode&gt;,  document.getElementById(&quot;root&quot;));\n\nsrc/TodoList.js\nimport React, &#123; Component &#125; from &quot;react&quot;;import &quot;antd/dist/antd.css&quot;;import &#123; Input &#125; from &quot;antd&quot;;import &#123; Button &#125; from &quot;antd&quot;;import &#123; List, Divider &#125; from &quot;antd&quot;;import store from &quot;./store/index&quot;;class TodoList extends Component &#123;  constructor(props) &#123;    super(props);    this.state = store.getState();    console.log(this.state);    this.handleInputChange = this.handleInputChange.bind(this);    this.handleStoreChange = this.handleStoreChange.bind(this);    this.handleBtnClick = this.handleBtnClick.bind(this);    store.subscribe(this.handleStoreChange);  &#125;  handleInputChange(e) &#123;    const action = &#123;      type: &quot;change_input_value&quot;,      value: e.target.value,    &#125;;    store.dispatch(action);  &#125;  handleStoreChange() &#123;    console.log(store.getState());    this.setState(store.getState());  &#125;  handleBtnClick() &#123;    const action = &#123;      type: &quot;add_list_item&quot;,    &#125;;    store.dispatch(action);  &#125;  handleItemClick(index) &#123;    const action = &#123;      type: &quot;delete_list_item&quot;,      index: index,    &#125;;    store.dispatch(action);  &#125;  render() &#123;    return (      &lt;div style=&#123;&#123; margin: &quot;20px auto&quot;, width: &quot;500px&quot; &#125;&#125;&gt;        &lt;Input          value=&#123;this.state.inputValue&#125;          placeholder=&quot;todo info&quot;          style=&#123;&#123; width: &quot;430px&quot; &#125;&#125;          onChange=&#123;this.handleInputChange&#125;        /&gt;        &lt;Button type=&quot;primary&quot; onClick=&#123;this.handleBtnClick&#125;&gt;          提交        &lt;/Button&gt;        &lt;Divider orientation=&quot;left&quot;&gt;Todo List&lt;/Divider&gt;        &lt;List          size=&quot;large&quot;          bordered          dataSource=&#123;this.state.list&#125;          renderItem=&#123;(item, index) =&gt; (            &lt;List.Item onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;              &#123;item&#125;            &lt;/List.Item&gt;          )&#125;        /&gt;      &lt;/div&gt;    );  &#125;&#125;export default TodoList;\n\nsrc/store/index.js\n// 创建storeimport &#123; createStore &#125; from &quot;redux&quot;;import reducer from &quot;./reducer&quot;;// 创建数据公共存储仓库// 调用createStore即可创建一个storeconst store = createStore(  reducer,  window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__());export default store;\n\nsrc/store/reducer.js\nconst defaultState = &#123;  inputValue: &quot;&quot;,  list: [],&#125;;// reducer可以接收state，但是绝不能修改state// state: Store中上一次存储的数据// action: 用户传递的actionexport default (state = defaultState, action) =&gt; &#123;  if (action.type === &quot;change_input_value&quot;) &#123;    // 对state进行一次深拷贝    const newState = JSON.parse(JSON.stringify(state));    // 修改input框中value的值    newState.inputValue = action.value;    return newState;  &#125;  if (action.type === &quot;add_list_item&quot;) &#123;    const newState = JSON.parse(JSON.stringify(state));    newState.list.push(newState.inputValue);    newState.inputValue = &quot;&quot;;    return newState;  &#125;  if (action.type === &quot;delete_list_item&quot;) &#123;    const newState = JSON.parse(JSON.stringify(state));    newState.list.splice(action.index, 1);    return newState;  &#125;  return state;&#125;;\n\n","tags":["前端","React","Redux"]},{"title":"同时使用Redux-devtools插件和Redux-thunk如何编写store和reducer","url":"/2021/04/08/11.%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8Redux-devtools%E6%8F%92%E4%BB%B6%E5%92%8CRedux-thunk%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99store%E5%92%8Creducer/","content":"同时使用Redux-devtools插件和Redux-thunk如何编写store和reducerRedux-thunk是Rudex的一个中间件。\n使用Redux-thunk，首先要安装Redux-thunk。\nnpm install --save redux-thunk\n\n在创建store的时候，来使用redux-thunk。\n// 创建storeimport &#123; createStore, applyMiddleware, compose &#125; from &quot;redux&quot;;import thunk from &quot;redux-thunk&quot;;import reducer from &quot;./reducer&quot;;// 创建数据公共存储仓库// 调用createStore即可创建一个store// 创建store的时候使用redux-thunk这个中间件// 实际上，chrome中的插件REDUX_DEVTOOLS也是一个redux中间件// 在github redux-devtools-extension中有同时使用这两个中间件的使用方法。如下const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__  ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;)  : compose;const enhancer = composeEnhancers(applyMiddleware(thunk));const store = createStore(reducer, enhancer);export default store;\n\n注意，是在创建Redux的store的时候使用了Redux的中间件。无论是Redux-thunk还是redux-devtools都是Redux的中间件。\n以上代码完成了一件事：安装了thunk，并且在Redux创建的时候使用了thunk。\nreducer的编写：\n// reducer.jsconst defaultState = &#123;&#125;;const reducer = (state = defaultState, action) =&gt; &#123;  // 此处编写自己关于action或者其他代码  return state;&#125;;export default reducer;\n\n","tags":["Redux","前端，React","Redux-thunk"]},{"title":"HTML+CSS面试题","url":"/2021/04/16/13.%20HTML+CSS%E9%9D%A2%E8%AF%95%E9%A2%98/","content":"HTML+CSS面试题HTML面试题HTML在面试中占比不大，面试的重点一般不会放在HTML上。\n\n如何理解HTML语义化？\n语义化是为了能够读懂代码：\n\n让人更容易读懂，增加代码的可读性。所有元素都使用&lt;div&gt;标签，与在段落使用&lt;p&gt;标签，列表使用&lt;ul&gt;，&lt;li&gt;，明显后者能更容易地去理解代码要表达的意思。\n\n让搜索引擎更容易读懂（SEO）。\n\n\n\n默认情况下，哪些HTML标签是块级元素，哪些是内联元素？\n\n块级元素：display: block/table; 有div, h1, h2, table, ul, ol, p等。块级元素独占一行。\n\n\n内联元素：display:inline/inline-block; 有span, img, input, button等。内联元素不会独占一行，会一直往后排列，直到浏览器的边缘或者换行为止。\n\n\n\nCSS面试题先梳理一下CSS的知识模块有哪些：\n\n布局\n定位\n图文样式。图片、文本宽度高度、颜色、字体等等属性的处理。涉及到一个重要的问题：如何继承\n响应式\nCSS3。重点是flex和动画。（动画不是面试的重点）\n\n布局\n盒子模型的宽度如何计算？\n\n\n​        offsetWidth = （内容宽度+内边距+边框），无外边距  ==&gt; 上图答案：122px\n​        补充：如果让offsetWidth等于100px，该怎么做？\n​        答案：添加box-sizing: border-box;\n\nmargin纵向重叠的问题\n\n\n​        相邻元素的margin-top和margin-bottom会发生重叠。\n​        空白内容的&lt;p&gt;&lt;/p&gt;也会重叠。\n​        上图答案：15px\n\nmargin负值的问题\n对margin的top, right, bottom, left设置负值，有何效果？\nmargin-top和margin-left设置负值，元素会向上、向左移动；\nmargin-right设置负值，右侧元素左移，自身不受影响；\nmargin-bottom设置负值，下方元素上移，自身不受影响。\n\nBFC的理解和应用\n什么是BFC？如何应用？\nBFC：Block Format Context，块级格式化上下文。是一块独立的渲染区域，内部元素的渲染不会影响边界以外的元素。\n\n形成BFC的常见条件：\nfloat不是none。只要设置了float，这个元素就形成了BFC；\nposition是absolute或fixed；\noverflow不是visible；（最常用，也是最简单的是overflow: hidden;）\ndisplay是flex，inline-block等。\n\n\nBFC的常见应用\n清除浮动\n\n\n\n\nfloat布局的问题，以及clearfix\n\n如何实现圣杯布局和双飞翼布局？（考察float布局的重要方式）\n圣杯布局和双飞翼布局的目的：\n\n三栏布局，中间一栏最先加载和渲染（内容最重要）\n两侧内容固定，中间内容随着宽度自适应\n一般用于PC网页\n\n圣杯布局和双飞翼布局的技术总结：\n\n使用float布局；\n两侧使用margin负值，以便和中间内容横向重叠；\n防止中间内容被两侧覆盖，一个是用padding（圣杯布局），一个是用margin（双飞翼布局）\n\n&lt;!-- 圣杯布局 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;圣杯布局&lt;/title&gt;    &lt;style&gt;      header &#123;        width: 100%;        height: 50px;        line-height: 50px;        text-align: center;        background-color: rgb(165, 154, 154);      &#125;      footer &#123;        clear: both;        width: 100%;        height: 50px;        line-height: 50px;        text-align: center;        background-color: rgb(165, 154, 154);      &#125;      .content &#123;        padding: 0 150px 0 200px;        position: relative;      &#125;      .main &#123;        background-color: rgb(190, 137, 137);        width: 100%;        float: left;      &#125;      .left &#123;        position: relative;        background-color: rgb(125, 179, 156);        width: 200px;        float: left;        margin-left: -100%;        right: 200px;      &#125;      .right &#123;        background-color: rgb(122, 150, 201);        width: 150px;        float: left;        margin-right: -150px;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;header&gt;header&lt;/header&gt;    &lt;div class=&quot;content&quot;&gt;      &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;      &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;      &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;    &lt;/div&gt;    &lt;footer&gt;footer&lt;/footer&gt;  &lt;/body&gt;&lt;/html&gt;\n\n&lt;!-- 双飞翼布局 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;双飞翼布局&lt;/title&gt;    &lt;style&gt;      header &#123;        height: 50px;        line-height: 50px;        background-color: rgb(177, 169, 169);        text-align: center;      &#125;      footer &#123;        height: 50px;        line-height: 50px;        background-color: rgb(177, 169, 169);        text-align: center;        clear: both;      &#125;      .content &#123;        width: 100%;      &#125;      .main &#123;        width: 100%;        background-color: rgb(235, 102, 102);        float: left;      &#125;      .main-wrap &#123;        margin: 0 150px 0 200px;      &#125;      .left &#123;        width: 200px;        background-color: rgb(228, 207, 88);        float: left;        margin-left: -100%;      &#125;      .right &#123;        width: 150px;        background-color: rgb(124, 238, 175);        float: left;        margin-left: -150px;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;header&gt;header&lt;/header&gt;    &lt;div class=&quot;content&quot;&gt;      &lt;div class=&quot;main&quot;&gt;        &lt;div class=&quot;main-wrap&quot;&gt;main&lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;      &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;    &lt;/div&gt;    &lt;footer&gt;footer&lt;/footer&gt;  &lt;/body&gt;&lt;/html&gt;\n\n圣杯布局和双飞翼布局的对比：\n\n圣杯布局是用过padding来为左右留白；而双飞翼布局是用过margin来为左右留白；\n圣杯布局中，left的内容使用了position: reletive;和right: 200px;，双飞翼布局没有用到相对定位，复杂度更加低一些；\n圣杯布局中right部分使用的是margin-right，双飞翼布局中使用的是margin-left。二者相比，margin-left要更容易理解一些；\n总的来说，双飞翼布局复杂度更低，理解起来更容易。\n简单来说，双飞翼布局比圣杯布局多创建了一个div，但是不用相对定位了。\n\n\n手写clearfix\n\n\n/* 手写clear-fix */.clear-fix:after &#123;  content: &quot;&quot;;  display: table;  clear: both;&#125;\n\n\n\nflex画骰子\n实现一个三点的骰子：一个骰子的一个面，左上角、中心、右下角各有一个点\n\nflex常用语法回顾：\n\n容器常用属性：flex-direction, justify-content, align-items, flex-wrap\n\n项目常用属性：align-self\n\n\n\n\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;flex画三色的骰子&lt;/title&gt;  &lt;/head&gt;  &lt;style&gt;    .box &#123;      width: 200px;      height: 200px;      border: 1px solid #000;      display: flex;      justify-content: space-between;    &#125;    .item &#123;      width: 50px;      height: 50px;      border-radius: 50%;      border: 1px solid #000;    &#125;    .item:nth-child(2) &#123;      align-self: center;    &#125;    .item:nth-child(3) &#123;      align-self: flex-end;    &#125;  &lt;/style&gt;  &lt;body&gt;    &lt;div class=&quot;box&quot;&gt;      &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n定位\nabsolute和relative分别依据什么定位？\nrelative依据自身定位；relative依据最近一层的定位元素定位（父元素一层一层往上找），定位元素包括：position属性为absolute, relative, fixed的元素以及&lt;body&gt;标签\n\n居中对齐有哪些实现方式？\n居中对齐分为水平居中和垂直居中。\n\n水平居中\ninline元素： text-align: center;\nblock元素：margin: auto;\nabsolute元素：left: 50%  + margin-left负值\n\n\n垂直居中\ninline元素：line-height: height的值\nabsolute元素：top: 50% + margin-top负值\nabsolute元素：top: 50% + transform: translate (-50%, -50%) （旧的浏览器兼容性可能存在问题，但是不需要知道子元素的宽高就可以实现）\nabsolute元素：top, left, bottom, right = 0 + margin: auto;（浏览器兼容性不存在问题，而且不需要知道子元素的尺寸）\n\n\n\n\n\n图文样式\nline-height的继承问题\n\n答案：40px。\n\n如果line-height是具体数值，如30px，则会继承该值；\n如果line-height是比例，如2或者1.5，则会继承该比例；\n如果line-height是百分比，如200%，则继承计算出来的值。（考点）\n\n\n\n响应式\nrem是什么？\nrem是一个长度单位。\n\npx，绝对长度单位，最常用；\nem，相对长度单位，相对于父元素，不常用；\nrem，相对长度单位，相对于根元素的font-size（&lt;html&gt;），常用于响应式布局。任何可以使用长度的地方都可以使用rem。\n\n\n如何实现响应式？\n\nmedia-query，根据不同屏幕的宽度设置根元素font-size；\nrem，基于根元素的相对单位。\n\n\nvw/vh\n\n背景：rem具有弊端——阶梯性\n\n\n\n网页视口尺寸\n\nwindow.screen.height：屏幕高度\nwindow.innerHeight：网页视口高度\ndocument.body.clientHeight：body高度\n\n\n\nvh：网页视口高度的1%（1/100）\n\nvw：网页视口宽度的1%（1/100）\n\nvmax：取vh和vw两者最大值；\n\nvmin：取vh和vw两者最小值；\n\n\n\n\n","tags":["前端","面试"]},{"title":"React-Redux的使用","url":"/2021/04/09/12.React-Redux%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"React-Redux的使用React-Redux是一个第三方模块，它可以帮助我们在React中更加方便地使用Redux。\n想使用React-Redux，首先需要安装。\nnpm install --save react-redux\n\n现在我们从零开始构建一个TodoList。\n创建React项目，index.html和index.js不再赘述。页面上挂载一个TodoList组件。\n// src/TodoList.jsimport React, &#123; Component &#125; from &quot;react&quot;;class TodoList extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;input&gt;&lt;/input&gt;        &lt;button&gt;添加&lt;/button&gt;        &lt;ul&gt;          &lt;li&gt;123&lt;/li&gt;          &lt;li&gt;123&lt;/li&gt;        &lt;/ul&gt;      &lt;/div&gt;    );  &#125;&#125;export default TodoList;\n\n页面的基本结构长这个样子。\n\n在项目中使用Redux，首先需要创建Store。\n在src目录下创建store文件夹，store文件夹中创建index.js，该文件中编写store。\n// src/store/index.jsimport &#123; createStore &#125; from &quot;redux&quot;;import reducer from &quot;./reducer&quot;;const store = createStore(reducer);export default store;\n\n创建好store之后，需要传递一个reducer给store。在store目录下创建reducer.js文件。\n// src/store/reducer.js// reducer是一个纯函数const defaultState = &#123;  inputValue: &quot;&quot;,  list: [],&#125;;const reducer = (state = defaultState, action) =&gt; &#123;  return state;&#125;;export default reducer;\n\n现在就创建好了store和reducer。\n回到TodoList.js中。\n在未使用React-Redux的时候，我们想获取值，需要在组件中调用store.getState()方法来获取state。现在我们要使用React-Redux，不需要这么做了。\n在使用React-Redux之后，我们可以更方便地在组件中使用Redux。\n来看React-Redux的写法。\n这里要用到Provider。\nProvider找到src下的index.js。改写成下面这样👇\nimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import &#123; Provider &#125; from &quot;react-redux&quot;;import TodoList from &quot;./TodoList&quot;;const App = (  &lt;Provider&gt;    &lt;TodoList /&gt;  &lt;/Provider&gt;);ReactDOM.render(App, document.getElementById(&quot;root&quot;));\n\n上面这段代码中，我们首先引入了Provider，它来自react-redux，它其实就是一个组件。\n然后我们定义了一个App组件，内容是一段JSX模板。在这个模板中，最外层使用&lt;Provider&gt;包裹，其中放入我们定义的&lt;TodoList&gt;组件。\n然后在挂载组件的时候，将&lt;App&gt;这个组件挂载到页面上。\n继续在src/index.js中写代码。\nimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import &#123; Provider &#125; from &quot;react-redux&quot;;import store from &quot;./store&quot;;import TodoList from &quot;./TodoList&quot;;const App = (  &lt;Provider store=&#123;store&#125;&gt;    &lt;TodoList /&gt;  &lt;/Provider&gt;);ReactDOM.render(App, document.getElementById(&quot;root&quot;));\n\n上面代码中，我们在src/index.js中引入了我们写好的store，然后在&lt;Provider&gt;上添加一个属性store，这个属性的值等于我们引入的store变量。\n这样写的意思是，&lt;Provider&gt;连接了store，那么&lt;Provider&gt;里面的所有组件都有能力获取到store中的内容。\n现在在TodoList这个组件中，就不再需要使用store.getState()来获取Store中的数据了。那么要怎么做呢？\n答：使用connect。\nconnect之前提到，&lt;Provider&gt;连接了store，那么&lt;Provider&gt;里面的所有组件都有能力获取到store中的数据。TodoList这个组件获取Store中的数据，就是通过connect方法。首先需要引入connect\n注意看最后一行代码。\n// src/Todolist.jsimport React, &#123; Component &#125; from &quot;react&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;class TodoList extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;input&gt;&lt;/input&gt;        &lt;button&gt;添加&lt;/button&gt;        &lt;ul&gt;          &lt;li&gt;123&lt;/li&gt;          &lt;li&gt;123&lt;/li&gt;        &lt;/ul&gt;      &lt;/div&gt;    );  &#125;&#125;// 导出的不再是TodoList这个组件，而是一个connect方法export default connect(null, null)(TodoList);\n\n按照之前的写法，我们应该导出的是TodoList这个组件。现在我们导出的不再是TodoList这个组件，而是一个connect方法，然后把TodoList传给这个方法。connect中可以写两个内容，我们暂且写为null。\n这么写的意思是，让TodoList组件和Store进行连接。connect方法完成的就是这个功能。因为TodoList组件是在Provider这个组件之中的，这个组件中的所有组件都有能力去连接Store，通过connect方法就可以进行连接。\n在与Store做连接的时候，需要有一定的连接方式。从而，衍生出了两个参数。\nconnect的两个参数mapStateToPropsmapStateToProps参数应该是一个函数，这个函数固定接收一个state，并且返回一个对象。\n然后把mapStateToProps放在connect方法的第一个参数中。\nconst mapStateToProps = (state) =&gt; &#123;  return &#123;&#125;;&#125;;// 导出的不再是TodoList这个组件，而是一个connect方法export default connect(mapStateToProps, null)(TodoList);\n\n这段代码的意思是，让组件TodoList和Store去做连接，连接的时候要有一定的规则，规则就在mapStateToProps中。\nmapStateToProps见明知义：将Store中的state映射为当前组件的props。这个函数中接收的state指的就是Store中的数据。\n现在来完善一下mapStateToProps这个“规则”。\n// src/Todolist.jsimport React, &#123; Component &#125; from &quot;react&quot;;import store from &quot;./store&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;class TodoList extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;input value=&#123;this.props.inputValue&#125;&gt;&lt;/input&gt;        &lt;button&gt;添加&lt;/button&gt;        &lt;ul&gt;          &lt;li&gt;123&lt;/li&gt;          &lt;li&gt;123&lt;/li&gt;        &lt;/ul&gt;      &lt;/div&gt;    );  &#125;&#125;const mapStateToProps = (state) =&gt; &#123;  return &#123;    inputValue: state.inputValue,  &#125;;&#125;;// 导出的不再是TodoList这个组件，而是一个connect方法export default connect(mapStateToProps, null)(TodoList);\n\n我们说，传入的state就是当前Store中的数据，state.inputValue就代表取出了Store中的inputValue的值。\ninputValue: state.inputValue就是将Store中的inputValue值映射为当前组件的props中的inputValue的值。也就是说，现在想在当前组件中使用inputValue，使用this.props.inputValue就可以使用这个值了。\n现在要实现的功能是，在输入框中输入内容，Store中对应的inputValue也应该能够动态的改变，并且显示在页面上。这就涉及到了向Store传值。在React-Redux中该如何向Store传值？这时候，第二个参数mapDispatchToProps就派上了用场。\nmapDispatchToProps第二个参数是mapDispatchToProps，这个参数同样应该是一个函数，这个函数固定接收一个dispatch方法，并且返回一个对象。\n然后把mapDispatchToProps放在connect方法的第二个参数中。\nconst mapDispatchToProps = (dispatch) =&gt; &#123;  return &#123;&#125;;&#125;;// 导出的不再是TodoList这个组件，而是一个connect方法export default connect(mapStateToProps, mapDispatchToProps)(TodoList);\n\n上面这段代码的意思是，将TodoList这个组件和Store进行关联，mapStateToProps参数规定了Store中的数据会映射到组件的props上面；同时，如果想对Store中的数据进行修改，也可以通过Store的props进行修改。\n现在来理解mapDispatchToProps。dispatch指的就是store.dispatch()，props指的也就是子组件接收到的props。我们现在相当于把Store的dispatch方法挂载到了props上。\n结合代码来理解。\n// src/Todolist.jsimport React, &#123; Component &#125; from &quot;react&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;class TodoList extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;input          value=&#123;this.props.inputValue&#125;          onChange=&#123;this.handleInputChange.bind(this)&#125;        &gt;&lt;/input&gt;        &lt;button&gt;添加&lt;/button&gt;        &lt;ul&gt;          &lt;li&gt;123&lt;/li&gt;          &lt;li&gt;123&lt;/li&gt;        &lt;/ul&gt;      &lt;/div&gt;    );  &#125;  handleInputChange(e) &#123;    console.log(e.target.value);  &#125;&#125;const mapStateToProps = (state) =&gt; &#123;  return &#123;    inputValue: state.inputValue,  &#125;;&#125;;const mapDispatchToProps = (dispatch) =&gt; &#123;  return &#123;&#125;;&#125;;// 导出的不再是TodoList这个组件，而是一个connect方法export default connect(mapStateToProps, mapDispatchToProps)(TodoList);\n\n现在在input框上绑定了一个onChange方法，一旦触发onChange事件，就会调用handleInputChange方法。也就是说，现在props中的数据发生了改变，我们想同步修改Store中的数据。\n想要改变Store中的内容，就需要调用store.dispatch()方法。\n现在store.dispatch()已经通过mapDispatchToProps映射到了props上，所以，this.props中应该有一个东西能够允许我们去调用store.dispatch()。\n那么，我们就在props中定义一个方法changeInputValue，将其绑定到onChange事件上。\n可是现在props本身并没有这个方法。现在就用到了mapDispatchToProps。让这个函数返回一个changeInputValue方法即可。\n// src/Todolist.jsimport React, &#123; Component &#125; from &quot;react&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;class TodoList extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;input          value=&#123;this.props.inputValue&#125;          onChange=&#123;this.props.changeInputValue&#125;        &gt;&lt;/input&gt;        &lt;button&gt;添加&lt;/button&gt;        &lt;ul&gt;          &lt;li&gt;123&lt;/li&gt;          &lt;li&gt;123&lt;/li&gt;        &lt;/ul&gt;      &lt;/div&gt;    );  &#125;&#125;const mapStateToProps = (state) =&gt; &#123;  return &#123;    inputValue: state.inputValue,  &#125;;&#125;;const mapDispatchToProps = (dispatch) =&gt; &#123;  return &#123;    changeInputValue(e) &#123;      const action = &#123;        type: &quot;change_input_value&quot;,        value: e.target.value,      &#125;;      dispatch(action);    &#125;,  &#125;;&#125;;// 导出的不再是TodoList这个组件，而是一个connect方法export default connect(mapStateToProps, mapDispatchToProps)(TodoList);\n\nmapDispatchToProps是一个函数，这个函数接收dispatch方法，使这个函数可以直接使用dispatch来转发action。\n接下来的逻辑就很简单了，定义action，转发给Store，Store再交给Reducer去做处理，处理完成后返回新数据给Store，Store再把新数据给到组件去渲染。\n// src/store/reducer.js// src/store/reducer.js// reducer是一个纯函数const defaultState = &#123;  inputValue: &quot;hello world&quot;,  list: [],&#125;;const reducer = (state = defaultState, action) =&gt; &#123;  if (action.type === &quot;change_input_value&quot;) &#123;    const newState = JSON.parse(JSON.stringify(state));    newState.inputValue = action.value;    return newState;  &#125;  return state;&#125;;export default reducer;\n\n\n\n小结\n现在接触了React-Redux中两个核心的东西。一个是Provider组件，另一个是connect方法。\nProvider可以帮助我们把store提供给每一个内部的组件。\n但是光提供store并不能起什么作用，还要通过connect方法将组件和Store进行连接。\nconnect方法接收三个参数，最后一个参数是某个组件，代表这个组件要和Store进行连接。前两个参数指的是连接的规则。这两个参数分别是mapStateToProps和mapDispatchToProps。\nmapStateToProps中定义的是Store中数据和组件Props中的数据的关系。\nmapDispatchToProps中将store.dispatch()映射到了props上，能够允许组件通过props对Store中的数据进行修改。\n\n","tags":["前端","React","Redux"]},{"title":"围绕React衍生出的思考","url":"/2021/03/31/2.%E5%9B%B4%E7%BB%95React%E8%A1%8D%E7%94%9F%E5%87%BA%E7%9A%84%E6%80%9D%E8%80%83/","content":"围绕React衍生出的思考声明式开发直接操作DOM的编程方式称为命令式开发，这种开发方式有60%-70%的操作都是在对DOM进行操作。\nReact是声明式开发。React是面向数据编程的，我们只需要把数据构建好，React会自动根据数据来构建网站。这种声明式的开发可以帮助我们节省掉大量DOM操作的代码。\n可以与其他框架并存React编程过程中，可以同时使用其他框架（比如Vue、jQuery等），即可以与其他框架并存。\n组件化开发通过React继承Component来实现一个组件。所有组件首字母均大写。\n组件在整个应用之中是一个树状的结构。\n组件之间的传值，是由父组件通过属性向子组件传值。\n子组件想操作父组件的数据，需要通过父组件向子组件传递一个方法，子组件调用这个方法，间接地操作父组件的数据，从而实现子组件和父组件的通信。\n单向数据流父组件可以向子组件传递内容，但是子组件只能使用父组件传递过来的值，绝不能改变这个值。\n如果允许子组件改变父组件的值，假设页面中有五个子组件使用了父组件中的同一个值，一旦页面出现bug，错误很难被定位，需要在五个子组件中逐个排查。\n视图层框架React是一个视图层的框架。\n在小型项目中，借助React内部的传值机制就可以完成开发，但是大型项目中单单使用React是绝对不够的。组件在整个项目之中是一个树状的结构，如果一颗树中的叶结点想和根结点进行通信，需要层层向下传值，这无疑是很麻烦的。\n在大型项目中，需要一些数据层的框架帮助我们解决层层组件的传值问题。React只负责数据和页面的渲染的一些东西，至于组件之间的传值，交给其他框架来做。比如Redux。\n函数式编程当我们编写React代码的时候，其实编写的都是一个个的函数。\n这样的方式有几个好处。\n首先，维护起来比较容易，当一个函数比较大的时候可以进行拆分，每个函数可以各司其职。\n其次，做前端自动化测试的时候，如果项目中都是由函数组成的，做自动化测试就很容易了，只需要给函数一个输入值，看函数是否能给出一个预期的输出即可。\n","tags":["前端","React"]},{"title":"React中的虚拟DOM","url":"/2021/03/31/3.React%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDOM/","content":"React中的虚拟DOM初识虚拟DOM首先思考一个问题。\n在之前的例子中，定义了数据state和render函数中的JSX模板，render函数可以将定义好的数据放进对应的模板之中，并且渲染到页面上。state中的数据改变，页面的显示也会随之改变。\n假设现在没有React，要想实现上述的功能，该怎么办？\n先提出一种思路：\n\n首先要定义好要显示的数据state；\n设定一个JSX模板，来容纳我们要显示数据；\n将数据state和模板相结合，生成真实的DOM，将DOM挂载到页面上来显示；\n此时数据state发生改变；\n将新的数据state和模板相结合，生成新的DOM，来替换原始的DOM，并挂载到页面上。\n\n以上就是最简单的实现React底层逻辑的一个思路。\n但是这样做的话，会有一个致命的缺陷。如果数据state中只稍微改动了一点，比如只去掉了一个p标签，或者甚至只是改动了一个字，就要重新生成一个完整的DOM。\n第一次生成了一个完整的DOM片段，第二次不管数据改动幅度有多大，都要再生成一个完整的DOM片段并且进行替换，无论是生成完整的DOM还是对整个DOM进行替换，这两种操作都十分损耗性能。\n那尝试改良一下，不替换整个DOM，而是哪里修改替换哪里。\n第二种思路，前三步和之前相同，区别在于数据修改后如何修改DOM：\n\n首先要定义好要显示的数据state；\n设定一个JSX模板，来容纳我们要显示数据；\n将数据state和模板相结合，生成真实的DOM，将DOM挂载到页面上来显示；\n此时数据state发生改变；\n将新的数据state和模板相结合，生成新的DOM，此时并不直接替换原有的DOM；\n将新的DOM与原始的DOM进行比对，寻找差异；\n用新的DOM中与原始DOM中不同的元素替换掉原来的元素，其余元素保持不变。\n\n乍一看好像比第一种思路多了很多步骤，但是确实会使性能提升一些。因为替换局部的DOM必定会比替换整个DOM的性能高。\n虽然DOM替换的性能节约了一些，但是新的DOM和原始DOM进行比对又会损耗性能。\n这样我们节约了一点性能，但是又消耗了一点性能，这就导致在性能的提升上并不明显。\n于是，React提出了一种方案——虚拟DOM。\n虚拟DOM的思路如下：\n\n首先要定义好要显示的数据state；\n\n设定一个JSX模板，来容纳我们要显示数据；\n\n将数据和state和模板相结合，生成虚拟DOM（虚拟DOM就是一个JS对象，用它来描述真实DOM）；\n假设此时的虚拟DOM为：\n[&#x27;div&#x27;, &#123;id: &#x27;abc&#x27;&#125;, [&#x27;span&#x27;, &#123;&#125;, &#x27;hello world&#x27;]]\n根据虚拟DOM的结构生成真实的DOM，将DOM挂载到页面上来显示；\n此时对应的真实DOM则为：\n&lt;div id=&quot;abc&quot;&gt;    &lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;\n此时数据state发生变化；\n\n数据state和模板相结合，生成新的虚拟DOM；\n[&#x27;div&#x27;, &#123;id: &#x27;abc&#x27;&#125;, [&#x27;span&#x27;, &#123;&#125;, &#x27;Byebye&#x27;]]\n比较原始虚拟DOM和新的虚拟DOM的区别，找到区别的地方（对应例子中span标签里的内容）；\n\n直接操作DOM，改变相应的内容（Span标签中的内容）。\n\n\n生成虚拟DOM是会耗费一点性能，但是虚拟DOM是一个JS对象，用JS生成一个JS对象的代价极低，反之，用JS生成一个DOM对象代价是很高的。\n所以，修改数据后生成虚拟DOM而不是真实DOM，极大地提升了性能；\n后续使用新的虚拟的DOM和原始虚拟进行对比，本质上比较的是两个JS对象，两个JS对象进行比对，对性能的消耗也是极小的，所以这一步也极大地提升了性能；\n找到差异之后直接操作对应的DOM进行操作，这样一整套流程下来，在性能提升方面有了质的飞跃。\n小结：\n虚拟DOM本质上就是JS对象，使用JS对象的操作来代替真实的DOM的操作，极大地提升了性能。\n深入了解虚拟DOM有了上述的理解之后，回过头来看代码。\n之前的render函数中会return一个JSX模板，里面的标签长得很像html标签：\nrender() &#123;  return (    &lt;div&gt;&#123;this.state.inputValue&#125;&lt;/div&gt;  );&#125;\n\n之前我们可能会认为return语句中的div标签就是一个DOM结点，但实际上这是一个JSX模板。React会把模板和数据相结合，结合完成后，生成的是一个虚拟DOM，有了虚拟DOM之后才会再生成真实DOM。\n那么JSX模板和真实DOM之间的关系就是：首先，JSX模板先会变成虚拟DOM（也就是一个JS对象），然后再被转换成真实的DOM。\nReact中将JSX语法转化为虚拟DOM，使用了React.createElement()方法。\n举例。以下两种写法是等价的。\nrender()&#123;  return &lt;div&gt;content&lt;/div&gt;;&#125;\n\nrender()&#123;  return React.createElement(&#x27;div&#x27;, &#123;&#125;, &#x27;content&#x27;);&#125;\n\nReact.createElement()方法是React中更偏向底层的一个接口。在此不做详细说明。\n虚拟DOM的优点\n性能提升了。DOM的比对变成了JS对象的比对。\n它使得跨端应用得以实现。（React Native）\n\n","tags":["前端","React"]},{"title":"React虚拟DOM中的diff算法","url":"/2021/04/01/4.React%E8%99%9A%E6%8B%9FDOM%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/","content":"虚拟DOM中的diff算法上一篇文章中提到了虚拟DOM的实现思想，可以分为以下7步：\n\n首先要定义好要显示的数据state；\n设定一个JSX模板，来容纳我们要显示数据；\n将数据和state和模板相结合，生成虚拟DOM（虚拟DOM就是一个JS对象，用它来描述真实DOM）；\n根据虚拟DOM的结构生成真实的DOM，将DOM挂载到页面上来显示；\n此时数据state发生变化；\n数据state和模板相结合，生成新的虚拟DOM；\n比较原始虚拟DOM和新的虚拟DOM的区别，找到有区别的地方；\n直接操作DOM，修改数据变动的部分。\n\n现在重点关注一下第7步。\n之前提到，虚拟DOM本质上是一个JS对象。现在要做的事情是两个虚拟DOM的比对，也就是两个JS对象的比对，这时需要思考一下，两个JS对象应该如何进行比对来寻找二者之间的差异？\n在React中，两个虚拟DOM进行比对采用的方式，就是diff算法。\ndiff算法根据上述虚拟DOM的实现思想可以知道，当数据发生变化的时候，虚拟DOM才会去做新的比对。那么什么时候才算数据发生了改变？\n当state或者props改变时，数据就发生了改变。props的改变也是因为父组件的state发生了改变，归根结底，数据发生变化都是因为调用了setState()方法。\n之前的文章中提到过，setState()是异步执行的。之所以异步，是为了提升React底层的性能。\n假设我们在很短的时间内连续调用三次setState()，即连续修改三次数据，React并不会进行三次虚拟DOM的比对，而是将三次setState()合并为一个setState()，只做一次虚拟DOM的比对，然后去更新一次DOM。这样的话，就可以省去两次虚拟DOM的比对带来的性能损耗。这就是setState()设为异步的初衷。\n\ndiff算法可以简单理解为，在对两个虚拟DOM进行比较时找不同的算法。\ndiff算法中有一个很重要的概念：同级比较。\n\n这张图中左边的树代表原始的虚拟DOM，右侧的树代表新生成的虚拟DOM。我们现在要用diff算法来比对这两棵树，找到差异之后去更新真实的DOM。\ndiff算法会怎么进行比对呢？同层比对。\n首先，会比较最顶层的虚拟DOM结点（图中红框部分），看这两个结点是否一致。假设这一层的两个结点一致，再去比较下一层，也就是第二层（图中紫框部分）。\n如果顶层的两个结点不一致，那么React就不会继续往下层比较了。React在发现第一层DOM存在差异之后，会把原始页面上的虚拟DOM对应的所有结点的DOM全部删除，重新生成所有DOM，然后用重新生成的DOM替换原始页面上的DOM。\n这样一来，如果在第一层就发现了差异，那么就会重新渲染整个DOM，这看起来性能比较低。\n事实上也确实如此，但是这样进行同层比对，带来的好处就是，比对的算法非常简单，只需要一层一层做对比即可。算法简单就会使得比对的速度很快，所以，虽然可能会造成DOM上重新渲染的性能浪费，但是会大大减少两个虚拟DOM进行比对的算法的性能消耗。\nkey值的引入\n假设现在有一个数组，数组中包含五个数据。在页面第一次渲染的时候，会把这五个数据映射成五个虚拟DOM结点，生成一个小的虚拟DOM树。\n现在，往数组里增加了一项内容（左图蓝色结点），于是，数据发生了变化，生成一个新的虚拟DOM树，然后将两个虚拟DOM进行比对（分别对应左图中上下两排结点），如果每一个虚拟DOM结点没有一个key值的话，每个结点都没有自己的名字。当我们进行比对的时候，结点和结点之间的关系就很难被确立。\n假如在进行虚拟DOM的比对时，可以给每一个虚拟DOM结点起一个名字，那么比较起来就方便多了（如右图）。虚拟DOM的比对可以根据key值做关联，如果原先DOM结点和新的DOM结点的key值一致，那么这个结点就可以复用。那么，只要把新的虚拟DOM树中和原来虚拟DOM树中key值不相同的结点进行相应的修改就可以了。这样的话，就极大地提高了虚拟DOM比对的性能。\n这样做的话，需要一个前提。原本的虚拟DOM树中的结点，在新的虚拟DOM树中的key值不能改变。所以需要使用一个稳定的值作为key值。不稳定的值，比如数组中的index，如果数组中的某一数据被删除，数据对应的索引值也会发生改变，index就是不稳定的值。\n小结：\nReact中的setState()的性能优化：可以将多次setState()合并为一次setState()，然后进行虚拟DOM的比对。\ndiff算法在比对两个虚拟DOM时采用逐层比对的策略，一旦有差异，下面的层便不会再进行比对，直接废弃掉，用新的虚拟DOM替换掉原先的虚拟DOM即可。\nReact在进行列表循环时引入key值，是为了提高虚拟DOM比对时的性能。key值要保持稳定。不要采用index作为key值。\n","tags":["前端","React"]},{"title":"React中的PropTypes与DefaultProps","url":"/2021/03/31/5.React%E4%B8%AD%E7%9A%84PropTypes%E4%B8%8EDefaultProps/","content":"React中的PropTypes与DefaultPropsPropTypes使用propTypes可以实现子组件属性接收的强校验。即子组件接收的属性的类型应该是固定的，父组件不能随便传值。\n回到之前的子组件TodoItem中。\n想要使用PropTypes，首先要引入PropTypes。\nimport PropTypes from &quot;prop-types&quot;;\n\n在TodoItem中以对象的形式添加属性强校验，添加到文件底部。\n// 属性强校验TodoItem.propTypes = &#123;  // content的类型必须是string类型  content: PropTypes.string,  // index的类型必须是number  index: PropTypes.number,  // delFunction的类型必须是function  delFunction: PropTypes.func,&#125;;\n\n如果传值类型不匹配，控制台会给出警告，警告不会阻止程序继续执行，但是会给出一个明显的提示。将content的类型设为number，会报以下警告。\n\n建议在开发过程中将PropTypes写上，这样一旦在传值过程中，有值传递错误时，会给出一些明显的提示。\n如果某个属性值并没有传值，则不会执行校验，设置PropTypes不会生效。\n如果要求必须给属性传值并且校验类型的话，要使用isRequired\n现在在子组件TodoItem中添加一个test属性，父组件中并没有这个属性。\nimport React, &#123; Component &#125; from &quot;react&quot;;import PropTypes from &quot;prop-types&quot;;class TodoItem extends Component &#123;  constructor(props) &#123;    super(props);    this.handleItemClick = this.handleItemClick.bind(this);  &#125;  handleItemClick() &#123;    const &#123; delFunction, index &#125; = this.props;    delFunction(index);  &#125;  render() &#123;    // 这里添加一个test属性，父组件并未传递这个属性    const &#123; content, test &#125; = this.props;    return (      &lt;li onClick=&#123;this.handleItemClick&#125; key=&#123;this.props.index&#125;&gt;        &#123;content&#125; - &#123;test&#125;      &lt;/li&gt;    );  &#125;&#125;// 属性强校验TodoItem.propTypes = &#123;  content: PropTypes.string,  index: PropTypes.number,  delFunction: PropTypes.func,  // 添加isRequired，要求这个属性值必须传递并且进行校验  test: PropTypes.string.isRequired,&#125;;export default TodoItem;\n\n因为父组件并没有传递test这个属性，所以控制台会报一个警告。\n\nPropTypes除了单一的类型，还可以有其他的写法。比如\nTodoItem.propTypes = &#123;  // content的类型必须是数组，数组中的值应该为string或number类型  content: PropTypes.arrayOf(PropTypes.string, PropTypes.number),&#125;;\n\n其他写法可以详见官网文档\nDefaultProps有时候父组件确实无法给某个属性传值，但是子组件中又要求这个属性必须有值，这时候就需要用到DefaultProps。\n同样要在子组件中以对象的形式进行定义。\n// 属性强校验TodoItem.propTypes = &#123;  content: PropTypes.string,  index: PropTypes.number,  delFunction: PropTypes.func,  // 添加isRequired，要求这个属性值必须传递并且进行校验  test: PropTypes.string.isRequired,&#125;;// 默认值TodoItem.defaultProps = &#123;  test: &quot;hello world&quot;,&#125;;\n\n以上代码表示，父组件需要给子组件传递一个test，类型为string，而且是必填的。如果父组件没有传这个test，则会给test一个默认值，这个默认值为hello world。这时，即使父组件没有向子组件传递test也没有关系，因为我们定义了默认值。\n\n","tags":["前端","React"]},{"title":"使用react-transition-group实现动画","url":"/2021/04/06/8.%E4%BD%BF%E7%94%A8react-transition-group%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB/","content":"使用react-transition-group实现动画首先安装react-transition-group。\nnpm install react-transition-group --save\n\n然后在组件中引入它。\nimport &#123; CSSTransition &#125; from &quot;react-transition-group&quot;;\n\n单个元素的动画CSSTransition本质上是一个组件。在render函数中使用CSSTransition包裹想要添加CSS的JSX标签，CSSTransition会帮助我们自动添加/删除CSS的class。\n这个组件要设置一些属性。\n\nin的属性：代表动画的状态，使用true和false来控制是入场动画还是出场动画。\ntimeout属性：代表动画持续时间\nclassNames属性（注意有个s）：代表class的前缀\nunmountOnExit属性：动画执行完毕之后，移除对应的DOM\nappear属性：布尔值，true代表第一次展示在页面上时也执行动画\n\nindex.js:\n// 使用JSX语法就要引入Reactimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import App from &quot;./App&quot;;ReactDOM.render(  &lt;React.StrictMode&gt;    &lt;App /&gt;  &lt;/React.StrictMode&gt;,  document.getElementById(&quot;root&quot;));\n\nApp.js:\nimport React, &#123; Component, Fragment &#125; from &quot;react&quot;;import &quot;./style.css&quot;;import &#123; CSSTransition &#125; from &quot;react-transition-group&quot;;class App extends Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      show: true,    &#125;;    this.handleToggle = this.handleToggle.bind(this);  &#125;  render() &#123;    return (      &lt;Fragment&gt;        &lt;CSSTransition          in=&#123;this.state.show&#125;          timeout=&#123;1000&#125;          classNames=&quot;fade&quot;          unmountOnExit          appear=&#123;true&#125;        &gt;          &lt;div&gt;app&lt;/div&gt;        &lt;/CSSTransition&gt;        &lt;button onClick=&#123;this.handleToggle&#125;&gt;toggle&lt;/button&gt;      &lt;/Fragment&gt;    );  &#125;  handleToggle() &#123;    this.setState(() =&gt; &#123;      return &#123;        show: this.state.show ? false : true,      &#125;;    &#125;);  &#125;&#125;export default App;\n\nstyle.css:\n/* 入场动画执行的第一个时刻 */.fade-enter,.fade-appear &#123;  opacity: 0;&#125;/* 入场动画执行的过程 */.fade-enter-active,.fade-appear-active &#123;  opacity: 1;  transition: opacity 1s ease-in;&#125;/* 入场动画执行完毕 */.fade-enter-done &#123;  opacity: 1;&#125;/* 出场动画执行的第一个时刻 */.fade-exit &#123;  opacity: 1;&#125;/* 出场动画执行的过程 */.fade-exit-active &#123;  opacity: 0;  transition: opacity 1s ease-in;&#125;/* 出场动画执行完毕 */.fade-exit-done &#123;  opacity: 0;&#125;\n\nCSS中的class名称含义：\n\n\n\n名称\n含义\n\n\n\n.xxx-enter\n入场动画执行的第一个时刻\n\n\n.xxx-enter-active\n入场后到入场动画结束的过程，在其中定义transition\n\n\n.xxx-enter-done\n入场动画执行完毕后\n\n\n.xxx-exit\n出场动画执行的第一个时刻\n\n\n.xxx-exit-active\n出场后到出场动画结束的过程，在其中定义transition\n\n\n.xxx-exit-done\n出场动画执行完毕后\n\n\n.xxx-appear\n当设置appear={true}时生效，第一次渲染时也执行入场动画，和.xxx-enter一起写\n\n\n.xxx-appear-active\n当设置appear={true}时生效，第一次渲染时执行的入场动画，和.xxx-enter-active一起写\n\n\n多个元素的动画想要多个元素实现相同的动画，需要使用TransitionGroup，同样需要提前引入\nimport &#123; CSSTransition, TransitionGroup &#125; from &quot;react-transition-group&quot;;\n\nTransitionGroup标签要写在所有组件的外部，每一个具体的DOM标签外仍然需要CSSTransition标签。\n改写后的App.js:\nimport React, &#123; Component, Fragment &#125; from &quot;react&quot;;import &quot;./style.css&quot;;import &#123; CSSTransition, TransitionGroup &#125; from &quot;react-transition-group&quot;;class App extends Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      list: [],    &#125;;    this.handleAddItem = this.handleAddItem.bind(this);  &#125;  render() &#123;    return (      &lt;Fragment&gt;        &lt;button onClick=&#123;this.handleAddItem&#125;&gt;toggle&lt;/button&gt;        &lt;TransitionGroup&gt;          &#123;this.state.list.map((item, index) =&gt; &#123;            return (              &lt;CSSTransition                timeout=&#123;1000&#125;                classNames=&quot;fade&quot;                unmountOnExit                appear=&#123;true&#125;                key=&#123;index&#125;              &gt;                &lt;div&gt;&#123;item&#125;&lt;/div&gt;              &lt;/CSSTransition&gt;            );          &#125;)&#125;        &lt;/TransitionGroup&gt;      &lt;/Fragment&gt;    );  &#125;  handleAddItem() &#123;    this.setState((prevState) =&gt; &#123;      return &#123;        list: [...prevState.list, &quot;item&quot;],      &#125;;    &#125;);  &#125;&#125;export default App;\n\n","tags":["前端","React"]},{"title":"React的生命周期函数","url":"/2021/04/06/7.React%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/","content":"React的生命周期函数生命周期函数指的是在某一时刻组件会自动调用执行的函数。\n\n各种生命周期函数Initialization阶段进行数据的设置（state, props），没有用到生命周期函数。\nMounting阶段\ncomponentWillMount: 在组件即将被挂载到页面的时刻自动执行。\nrender: 做页面的挂载。\ncomponentDidMount: 在组件被挂载到页面之后自动执行。\n\nUpdation阶段只在数据发生变化时进入这个阶段。在组件更新的过程中(props或state发生变化)，会涉及一些新的生命周期函数。\nprops和state发生变化时，执行的生命周期函数略有不同（props多了一个componentWillReceiveProps）。\n先来看相同的部分：\n\nshouldComponentUpdate: 组件更新之前会被自动执行。该函数要求返回一个布尔值。true代表需要更新，false代表不更新。\ncomponentWillUpdate: 组件被更新之前自动执行，在shouldComponentUpdate之后被执行。如果shouldComponentUpdate返回true才会执行；如果返回false则不会执行。\nrender\ncomponentDidUpdate: 组件更新完成之后会被执行。\n\n接下来是props改变时独有的生命周期函数componentWillReceiveProps。\n如果一个组件没有接收props参数（比如顶层组件），componentWillReceiveProps这个生命周期函数是不会被执行的。\ncomponentWillReceiveProps: 当一个组件从父组件接收参数，如果这个组件第一次存在于父组件中，不会被执行；如果这个组件之前已经存在于父组件中，才会执行。\nUnmounting阶段componentWillUnmount: 当前组件即将被从页面中剔除的时候会被执行。\n生命周期函数使用场景性能优化当父组件中的数据发生改变，render函数就会执行。父组件的render函数执行，子组件的render函数也会执行。如果父组件的数据改变了，但是并不想让子组件重新渲染，就可以使用生命周期函数来进行性能上的优化。\n利用shouldComponentUpdate\nshouldComponentUpdate(nextProps, nextState) &#123;  // nextProps: 组件更新时，接下来props会变化为什么样  // nextState: 组件更新时，接下来state会变化为什么样  // content是自定义的属性名  if (nextProps.content !== this.props.content) &#123;    return true;  &#125; else &#123;    return false;  &#125;&#125;\n\n发送Ajax请求在componentDidMount中发送Ajax请求。\n如果将Ajax请求放到render中，render函数会在数据改变时执行，这样会多次发送Ajax请求。应该寻找只会执行一次的生命周期函数，在其中发送一次Ajax请求即可。\ncomponentDidMount() &#123;  axios    .get(&quot;/api/todolist&quot;)    .then(() =&gt; &#123;      alert(&quot;success&quot;);    &#125;)    .catch(() =&gt; &#123;      alert(&quot;error&quot;);    &#125;);&#125;\n\n在React中使用Ajax需要安装axios。\nnpm install axios\n\n然后在组件中引入axios\nimport axios from &quot;axios&quot;;\n\n接着便可以发送Ajax请求来获取数据了\n一个示例：\ncomponentDidMount() &#123;  axios    .get(      &quot;https://www.fastmock.site/mock/0775a4a75216a7011e70b328b9dce604/todolist/todolist&quot;    )    .then((res) =&gt; &#123;      this.setState(() =&gt; (&#123; list: [...res.data] &#125;));    &#125;)    .catch(() =&gt; &#123;      alert(&quot;error&quot;);    &#125;);&#125;\n\n","tags":["前端","React"]},{"title":"创建Redux中的Store","url":"/2021/04/07/9.%E5%88%9B%E5%BB%BARedux%E4%B8%AD%E7%9A%84Store/","content":"创建Redux中的Store 以实现一个Todo List为例。下面是效果图。\n\nstore的创建与数据获取首先要安装Redux\nnpm install redux\n\n在src目录下创建一个folder，folder的名字就叫做store。\n在store文件夹下创建index.js，在这个文件中创建store。\n创建store的同时也要创建reducer。所以在store目录下创建一个reducer.js，在这个文件中只需要返回一个函数\n/src/store/index.js:\nimport &#123; createStore &#125; from &quot;redux&quot;;// 创建数据公共存储仓库// 调用createStore即可创建一个storeconst store = createStore();export default store;\n\n但是这样并不够。\n回顾一下Redux的工作流程。\n\n假设这样一个场景：你去一个图书馆借书，你对图书管理员说：“请问有《JavaScript高级程序设计》这本书吗？”。图书管理员要去电脑上的资料库中检索，找到这本书的位置在哪，然后取到这本书，交给你。\n图中的React Components就对应上述场景的“你”，Action Creators对应“请问有《JavaScript高级程序设计》这本书吗？”这句话，Store对应图书管理员，Reducers对应电脑上的资料库。\n那么现在再来梳理一下。\nReact Components（React中的组件）想要获取数据，就发出了一个请求Action Creators（暂时理解为请求，并不准确），Store感知到了这个请求，就去Reducers中搜索对应的数据，拿到之后将数据返回给组件。\n所以现在创建Store的时候，需要同时创建Reducers，然后给到Store。也就是说，需要给图书管理员一个书籍的目录，这样图书管理员才知道有哪些书，对应的书在什么地方，否则这个图书管理员什么也不知道。\n在store目录下创建一个reducer.js\n在Redux中，reducer的代码需要返回一个函数。这个函数需要接收两个参数：state和action。state对应整个仓库中存储的数据，可以给state一个默认值来存储默认数据。函数默认返回state即可。\nsrc/store/reducer.js\n// 对于todolist来讲，需要两类数据，一个是输入框中的数据，另一个是需要展示的列表数据const defaultState = &#123;  inputValue: &quot;&quot;,  list: [],&#125;;export default (state = defaultState, action) =&gt; &#123;  return state;&#125;;\n\n创建好reducer之后，要把reducer传给store。\nsrc/store/store.js\n// 创建storeimport &#123; createStore &#125; from &quot;redux&quot;;import reducer from &quot;./reducer&quot;;// 创建数据公共存储仓库// 调用createStore即可创建一个storeconst store = createStore(reducer);export default store;\n\n这样，store就可以通过reducer来查看仓库中的数据。\n现在想在组件中使用store中的数据，该怎么做？\n首先需要在组件中引入store\nimport store from &quot;./store/index&quot;;\n\nstore提供了一个getState()方法，使用这个方法就可以获取store中的数据。将获取到的数据放到当前组件的this.state中，就可以当作组件本身的数据来使用了。\nimport React, &#123; Component &#125; from &quot;react&quot;;import &quot;antd/dist/antd.css&quot;;// 这里使用了Ant Designimport &#123; Input &#125; from &quot;antd&quot;;import &#123; Button &#125; from &quot;antd&quot;;import &#123; List, Divider &#125; from &quot;antd&quot;;import store from &quot;./store/index&quot;;class TodoList extends Component &#123;  constructor(props) &#123;    super(props);    // 这里获取到了store中的数据    this.state = store.getState();    console.log(this.state);  &#125;  render() &#123;    return (      &lt;div style=&#123;&#123; margin: &quot;20px auto&quot;, width: &quot;500px&quot; &#125;&#125;&gt;        &lt;Input          value=&#123;this.state.inputValue&#125;          placeholder=&quot;todo info&quot;          style=&#123;&#123; width: &quot;430px&quot; &#125;&#125;        /&gt;        &lt;Button type=&quot;primary&quot;&gt;提交&lt;/Button&gt;        &lt;Divider orientation=&quot;left&quot;&gt;Todo List&lt;/Divider&gt;        &lt;List          size=&quot;large&quot;          bordered          dataSource=&#123;this.state.list&#125;          renderItem=&#123;(item) =&gt; &lt;List.Item&gt;&#123;item&#125;&lt;/List.Item&gt;&#125;        /&gt;      &lt;/div&gt;    );  &#125;&#125;export default TodoList;\n\nChrome中的插件redux devtools\n安装完成后，在创建store的createStore函数中传入第二个参数window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()\n// 创建storeimport &#123; createStore &#125; from &quot;redux&quot;;import reducer from &quot;./reducer&quot;;const store = createStore(  reducer,  window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__());export default store;\n\n然后就可以在chrome的控制台中方便地进行redux的调试。\n\n","tags":["前端","React","Redux"]},{"title":"ES6（一）let & const","url":"/2021/03/18/ES6%EF%BC%88%E4%B8%80%EF%BC%89let%20&%20const/","content":"ES6 let&amp;const命令let和const是ES6中新增的两个声明变量的命令。\n基本用法和var相同，区别在于let和const声明的变量只在声明的代码块内有效。\nif (true) &#123;    let myName = &quot;Orla&quot;;&#125;console.log(myName);\t\t// Uncaught ReferenceError: myName is not defined\n\nlet代替var来声明变量，const代替var来声明常量。\nvar和let声明的是变量，变量初始化后还可以重新赋值；const声明的常量一旦初始化，就不能重新赋值，否则会报错。（实际上不是常量的值不可以改变，而是指向的内存地址不可以改变，此处针对引用数据类型）\nconst person = &#123;    name: &quot;Orla&quot;,    age: 20,&#125;;person.name = &quot;Zhangsan&quot;;console.log(person);\n\n\n\n\nlet&amp;const与var的区别不存在变量提升var命令存在变量提升现象，即变量可以在声明之前使用，其值为undefined。但这并不符合逻辑。let&amp;const消除了这种现象，变量必须在声明之后才能使用。\nconsole.log(a); // undefinedvar a = 10;console.log(b); // 报错 Uncaught ReferenceError: Cannot access &#x27;b&#x27; before initializationlet b = 20;\n\n\n\n重复声明let/const不允许在相同作用域内重复声明同一个变量。\n暂时性死区(TDZ)只要作用域中存在let/const，它们所声明的变量/常量就自动“绑定”这个区域，不再受到外部作用域的影响。只要在声明语句之前使用let/const声明的变量，就会报错。简言之，使用let/const命令声明变量之前，该变量都是不可用的，这就被称作暂时性死区。\nlet a = 20;function func() &#123;    // let不存在变量提升，let声明的a与该区域绑定，不受外部影响    console.log(a); // Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization    let a = 10;&#125;func();\n\n暂时性死区也意味着typeof不再是一个百分百安全的操作。\n&#123;\ttypeof a; // Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization    let a = [];&#125;\n\n\n\nwindow对象的属性和方法全局作用域中，var声明的变量以及通过function声明的函数，会自动变成window对象的属性和方法。let、const不会。\nvar a = 10;let b = 20;const c = 30;function add() &#123;&#125;console.log(window.a); // 10console.log(window.b); // undefinedconsole.log(window.c); // undefinedconsole.log(window.add === add); // true\n\n\n\n块级作用域以for循环为例。如果使用let，i只在for循环体内有效，在循环体外引用就会报错。\nfor (let i = 0; i &lt; 10; i++) &#123;  // ...&#125;console.log(i);// ReferenceError: i is not defined\n\n如果使用var，则会输出10（因为ES5中没有块级作用域）。\n// 变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i// 每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i// 也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。var a = [];for (var i = 0; i &lt; 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[8](); // 10\n\n\n\n如果使用let，声明的变量仅在块级作用域内有效。\n// 变量i是let声明的，当前的i只在本轮循环有效// 每一次循环的i其实都是一个新的变量// for循环的计数器就很适合用let，不会出现全局变量改变的情况var a = [];for (let i = 0; i &lt; 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[8](); // 8\n\n\n\nfor循环有一个特别之处:循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。\nfor (let i = 0; i &lt; 3; i++) &#123;  let i = &#x27;abc&#x27;;  console.log(i);&#125;// abc// abc// abc\n\n","tags":["ES6"]},{"title":"单行/多行文字溢出省略","url":"/2021/03/23/%E5%8D%95%E8%A1%8C%E5%A4%9A%E8%A1%8C%E6%96%87%E5%AD%97%E6%BA%A2%E5%87%BA%E7%9C%81%E7%95%A5/","content":"前端——单行/多行文字溢出省略单行文字省略样式代码，添加对应的class即可.text-ellipsis&#123;    overflow: hidden;    text-overflow: ellipsis;    white-space: nowrap;&#125;\n\n示例：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;单行文字溢出省略&lt;/title&gt;    &lt;style&gt;      * &#123;        margin: 0;        padding: 0;      &#125;      .container &#123;        margin: 20px auto;        width: 300px;        border: 1px solid #eee;      &#125;      li &#123;        display: block;        list-style: none;        color: rgb(158, 152, 152);        border-bottom: 1px dashed rgb(158, 152, 152);        margin: 10px;      &#125;      .text-ellipsis &#123;        overflow: hidden;        text-overflow: ellipsis;        white-space: nowrap;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;ul&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n效果：\n多行文字省略样式代码，添加对应的class即可.multiline-ellipsis&#123;    overflow: hidden;    text-overflow: ellipsis;    display: -webkit-box;    /* 设置文字显示行数 */    -webkit-line-clamp: 2;    -webkit-box-orient: vertical;    white-space: normal !important;    word-wrap: break-word;&#125;\n\n示例：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;多行文字溢出省略&lt;/title&gt;    &lt;style&gt;      .container &#123;        width: 300px;        margin: 20px auto;        border: 1px solid rgb(155, 147, 147);      &#125;      .multiline-ellipsis &#123;        overflow: hidden;        text-overflow: ellipsis;        display: -webkit-box;        /* 设置文字显示行数 */        -webkit-line-clamp: 2;        -webkit-box-orient: vertical;        white-space: normal !important;        word-wrap: break-word;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;h3&gt;岳阳楼记&lt;/h3&gt;      &lt;p class=&quot;multiline-ellipsis&quot;&gt;        庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴，乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上，属予作文以记之。&lt;br /&gt;        予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯，朝晖夕阴，气象万千，此则岳阳楼之大观也，前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？&lt;br /&gt;        若夫淫雨霏霏，连月不开，阴风怒号，浊浪排空，日星隐曜，山岳潜形，商旅不行，樯倾楫摧，薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣。&lt;br /&gt;        至若春和景明，波澜不惊，上下天光，一碧万顷，沙鸥翔集，锦鳞游泳，岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧，渔歌互答，此乐何极！登斯楼也，则有心旷神怡，宠辱偕忘，把酒临风，其喜洋洋者矣。&lt;br /&gt;        嗟夫！予尝求古仁人之心，或异二者之为，何哉？不以物喜，不以己悲，居庙堂之高则忧其民，处江湖之远则忧其君。是进亦忧，退亦忧。然则何时而乐耶？其必曰“先天下之忧而忧，后天下之乐而乐”乎！噫！微斯人，吾谁与归？&lt;br /&gt;        时六年九月十五日。      &lt;/p&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n效果：\n","tags":["前端","css"]},{"title":"移动端事件","url":"/2021/03/19/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6/","content":"移动端事件移动端事件一共有三类：触摸事件、手势(gesture)事件以及传感器(sensor)事件。其中，触摸事件又可分为touch事件和pointer事件。\n触摸事件touch事件touch分类touch事件可分为touchstart, touchmove, touchend和touchcancel四种。\ntouchstart：手指触摸到屏幕时会触发\ntouchmove：手指按在屏幕上并移动时触发\ntouchend：手指离开屏幕时触发\ntouchcancel：通常是系统级的事件触发。比如正在滑动屏幕时有电话打进来，页面切换到了通话界面，此时就会触发touchcancel事件。\n举个栗子：\n&lt;!-- 页面上存在一个div --&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;\n\n/* 为其设置样式 */#box &#123;  width: 150px;  height: 150px;  background-color: rgb(236, 148, 148);  margin: 20px auto;  color: #fff;  font-weight: bold;  text-align: center;  line-height: 150px;&#125;\n\nconst box = document.getElementById(&quot;box&quot;);// 绑定三个touch事件box.addEventListener(&quot;touchstart&quot;, handleStart, false);box.addEventListener(&quot;touchmove&quot;, handleMove, false);box.addEventListener(&quot;touchend&quot;, handleEnd, false);function handleStart() &#123;  box.innerText = &quot;我被点了&quot;;  console.log(&quot;touchStart&quot;);&#125;function handleMove() &#123;  box.innerText = &quot;正在移动...&quot;;  console.log(&quot;touchMove&quot;);&#125;function handleEnd() &#123;  box.innerText = &quot;松开了！&quot;;  console.log(&quot;touchEnd&quot;);&#125;\n\n当手指在盒子内部点击盒子、移动手指、松开手指时，效果如下：\n\n当手指在盒子外部点击、移动、松开时，不会触发事件，即使手指在这个过程中移动到了盒子上：\n\n当手指在盒子内部点击，并滑出盒子范围后，事件依然会触发：\n\ntouch事件的event对象每个touch事件都会有event对象，每次touch的信息都会包含在event对象中。\n将上面的代码中的event打印出来。\nfunction handleStart(ev) &#123;        box.innerText = &quot;我被点了&quot;;        console.log(&quot;touchStart&quot;, ev);      &#125;      function handleMove(ev) &#123;        box.innerText = &quot;正在移动...&quot;;        console.log(&quot;touchMove&quot;, ev);      &#125;      function handleEnd(ev) &#123;        box.innerText = &quot;松开了！&quot;;        console.log(&quot;touchEnd&quot;, ev);      &#125;\n\n以touchstart中的event为例：\n\n我们这里重点关注三个属性：changedTouches, targetTouches和touches。\n这三个属性几乎包含了我们手指点击屏幕时所有信息。这三个属性其实都是类数组对象，具有下标和length，但是没有数组的方法。\ntouches的length代表触摸屏幕的手指数，有多少根手指触摸屏幕，length就是多少。\ntargetTouches的length代表触摸事件绑定元素的手指数，如果手指落在该绑定元素的范围外，则不计入length。\nchangedTouches的length代表触摸事件绑定元素并移动的手指数。注意：假设只有一根手指点击屏幕。当触发touchend时，代表手指离开屏幕时的事件被触发，此时没有手指触摸屏幕，所以此时的touches和targetTouches的length均为0。但是可以检测到手指离开了屏幕，changedTouches的length为1。\n所以推荐使用changedTouches来获取手指触摸时的信息。防止其他属性获取不到touchend事件的相关信息。\nfunction handleEnd(ev) &#123;        box.innerText = &quot;松开了！&quot;;        console.log(&quot;touchEnd&quot;, ev);        console.log(ev.changedTouches);      &#125;\n\n此时输出的就是我们触摸屏幕时的一些信息，包含触摸点的坐标等。这样我们就可以方便地获取到这些信息。\n\n一个小案例：图标拖拽   const backtop = document.getElementById(&quot;backtop&quot;);   // 存放每次开始移动时的手指坐标   const startPoint = &#123;&#125;;   // 实现拖动的函数drag()   // element是绑定的元素   // options是用户传入的参数，&#123;x: true/false, y: true/false&#125;，代表x和y方向上是否允许移动   function drag(element, options) &#123;     options.x = typeof options.x === undefined ? false : options.x;     options.y = typeof options.y === undefined ? false : options.y;     // x, y方向均不允许移动     if (!options.x &amp;&amp; !options.y) return;     const curPoint = &#123;       x: 0,       y: 0,     &#125;;     // 添加touch事件监听     element.addEventListener(&quot;touchstart&quot;, handleStart, false);     element.addEventListener(&quot;touchmove&quot;, handleMove, false);     element.addEventListener(&quot;touchend&quot;, handleEnd, false);     function handleStart(ev) &#123;       const touch = ev.changedTouches[0];       // 记录每次按下屏幕的坐标       startPoint.x = touch.pageX;       startPoint.y = touch.pageY;       // console.log(startPoint.x);     &#125;     function handleMove(ev) &#123;       const touch = ev.changedTouches[0];       const diffPoint = &#123;&#125;;       // 保存移动后的坐标点       const movePoint = &#123; x: 0, y: 0 &#125;;       // 计算从按下屏幕到拖动结束移动的距离       // startPoint是每次按下屏幕的坐标       // diffPoint代表每次移动的距离       diffPoint.x = touch.pageX - startPoint.x;       diffPoint.y = touch.pageY - startPoint.y;       // curPoint代表上一次拖拽完成后的坐标，初始为&#123;x: 0, y: 0&#125;       if (options.x) &#123;         movePoint.x = curPoint.x + diffPoint.x;       &#125;       if (options.y) &#123;         movePoint.y = curPoint.y + diffPoint.y;       &#125;\t       // 使用translat3d来改变位置(考虑性能优化，在移动端这条属性会开启GPU加速)       this.style.transform = `translate3d($&#123;movePoint.x&#125;px, $&#123;movePoint.y&#125;px, 0)`;     &#125;     function handleEnd(ev) &#123;       const touch = ev.changedTouches[0];       // 手指离开屏幕，完成了一次拖拽，更新当前坐标位置       // startPoint是每次按下屏幕的坐标       // touch.pageX - startPoint.x代表移动的距离       // curPoint代表上一次拖拽完成后的坐标       // 新的移动后的坐标 = 移动距离 + 初始的坐标       curPoint.x += touch.pageX - startPoint.x;       curPoint.y += touch.pageY - startPoint.y;     &#125;   &#125;// 调用函数，x, y 方向均允许拖拽   drag(backtop, &#123; x: true, y: true &#125;);\n\n\n\n实现效果：\n\n其他触摸事件在现实中，我们用到的往往不是简单的touch，而是一些比较复杂的事件，比如双击、长按屏幕、左右滑动、缩放页面等操作。\n\n想要实现这些复杂的事件，需要使用touch进行封装。\nhammer.min.js已经将这些复杂的操作封装好了，直接下载引用即可。\n一个例子：为一个id为box的div使用hammer.min.js添加事件监听：\n首先需要引入hammer.min.js文件。\n&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/hammer.min.js&quot;&gt;&lt;/script&gt;\n\n然后使用Hammer()函数创建hammer对象，其中传入要绑定的元素。然后使用hammer.on()监听需要监听的事件即可。\nconst box = document.getElementById(&quot;box&quot;);let hammer = new Hammer(box);// swipe: 快速滑动// pan: 拖动// tap: 轻点,类似click,最大点击时间为250ms,超过则按press事件处理// doubletap: 双击// press: 可以理解为长按// pinch: 两个手指（默认为两个手指，多指触控需要单独设置）//        或多个手指相对（越来越近）移动或相向（越来越远）移动时事件// rotate: 当两个手指或更多手指呈圆型旋转时触发hammer.on(&quot;swipe pan tap doubletap press pinch rotate&quot;, function (ev) &#123;  // 输出触发事件对应的名称  console.log(ev.type);&#125;);\n\n","tags":["前端","移动端"]},{"title":"React基础","url":"/2021/03/25/1.React%E5%9F%BA%E7%A1%80/","content":"React基础什么是组件简单来说，组件就是页面上的一部分。一个页面由多个组件构成。多个组件共同渲染出一个页面。\n\n想让一个组件往页面上渲染内容，需要在这个组件中写一个render()函数\nreact渲染页面的流程：\nindex.html –&gt; 执行index.js –&gt; index.js中引入组件 –&gt; 组件通过render()函数来定义需要渲染的内容 –&gt; 组件在index.js中被引入，使用ReactDom.render()挂载到index.html中\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;    &lt;title&gt;Orla React&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n// index.jsimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;// 引入组件import App from &quot;./App&quot;;import Test from &quot;./Test&quot;;// ReactDom.render在渲染的时候只能渲染单标签ReactDOM.render(  // JSX语法  // 想要渲染多个标签，使用JSX语法，将多个标签放入一个div中即可  &lt;div&gt;    &lt;App /&gt;    &lt;Test /&gt;  &lt;/div&gt;,  // 将App组件的内容挂载到index.html页面id为root的节点上  document.getElementById(&quot;root&quot;));\n\n// App.js 定义App组件import React, &#123; Component &#125; from &quot;react&quot;;// 使用class定义了一个组件// 要往页面上渲染的内容需要写在render()函数中class App extends Component &#123;  render() &#123;    return &lt;div&gt;Hello World&lt;/div&gt;;  &#125;&#125;// function App() &#123;//   return &lt;div&gt;hello world&lt;/div&gt;;// &#125;export default App;\n\n// Test.js 定义Test组件import React, &#123; Component &#125; from &quot;react&quot;;// 使用class定义了一个组件// 要往页面上渲染的内容需要写在render()函数中class Test extends Component &#123;  render() &#123;    return &lt;div&gt;Test组件&lt;/div&gt;;  &#125;&#125;export default Test;\n\n页面效果：\n\nJSX语法React 使用 JSX 来替代常规的 JavaScript。JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。\nJSX语法中，有两种类型的标签：\n\n普通的html标签（div…）\n组件标签（比如上面的&lt;App /&gt;），首字母一定要大写\n\n使用React编写ToDoList下面的代码都是基于TodoList进行编写的。使用代码需要预先创建React项目。可以使用React官方提供的脚手架工具create-react-app快速创建一个React项目（需要nodejs环境）。命令如下：\n$ npx create-react-app my-app$ cd my-app$ npm start$ npm install\n\n如上命令创建了一个名为my-app的项目。使用该项目的目录结构即可。\nTodoList的功能：\n\n输入文字，按下回车，添加对应内容至列表中\n\n点击列表项能够删除该项\n实现效果如下：\n\n\n\n页面结构首先在页面中实现一个静态的input框和ul列表。\n需要注意的是，render一次只能渲染一个外部标签， 想要渲染多个标签，同时不想用div包裹起来导致dom会新增无用的div标签，可以使用React中提供的Fragment标签。\n// index.jsimport React from &quot;react&quot;;import ReactDom from &quot;react-dom&quot;;// 引入组件import TodoList from &quot;./TodoList&quot;;ReactDom.render(&lt;TodoList&gt;&lt;/TodoList&gt;, document.getElementById(&quot;root&quot;));              \n\n// TodoList.js, TodoList组件，组件开头字母大写// 引入Fragment组件import React, &#123; Component, Fragment &#125; from &quot;react&quot;;class TodoList extends Component &#123;  render() &#123;    // render一次只能渲染一个外部标签，想渲染多个，需要将标签放在一个div中。    // 但是这样的做法会导致dom中多出来一个div    // React16中提供了占位符组件Fragment    // 将所有组件放在Fragment中，不会在dom中添加其他的元素    return (      &lt;Fragment&gt;        &lt;input /&gt;        &lt;ul&gt;          &lt;li&gt;Learn React&lt;/li&gt;          &lt;li&gt;Learn Component&lt;/li&gt;        &lt;/ul&gt;      &lt;/Fragment&gt;    );  &#125;&#125;export default TodoList;\n\nReact中数据驱动的设计思想和事件绑定★React是一个数据驱动的框架，所有功能都不直接操作DOM，而是直接操作数据。\nTodoList中的数据分为两部分：input中的数据和ul列表中的数据。需要在代码中把这两种数据定义出来。\n在组件中定义数据，要在render()函数上面写constructor()函数。constructor中接收参数props，并且要调用父类的构造函数，将props传递给父类的构造函数。所以要固定写super函数。\n// 定义组件中的数据constructor(props) &#123;  // 接收参数props，传递给基类(Component)的构造函数  super(props);&#125;\n\n前面提到，TodoList中的数据分为两部分：input中的数据和ul列表中的数据。我们要在constructor函数中，把这两种数据定义出来。\nReact中，定义组件的数据要放在this.state中，以对象的形式进行定义。\nconstructor(props) &#123;    // 接收参数props，传递给基类(Component)的构造函数    super(props);    // React中，定义组件的数据要放在this.state中    // inputValue定义input输入框中的数据    // list定义ul列表中的数据    this.state = &#123;      inputValue: &quot;hello World&quot;,      list: [],    &#125;;  &#125;\n\n定义好数据后，将数据放到要渲染的标签中即可。使用花括号将其包裹起来。\nrender() &#123;  return (    &lt;Fragment&gt;      &#123;/* 使用花括号将数据包裹起来 */&#125;      &lt;input value=&#123;this.state.inputValue&#125; /&gt;      &lt;ul&gt;        &lt;li&gt;Learn React&lt;/li&gt;        &lt;li&gt;Learn Component&lt;/li&gt;      &lt;/ul&gt;    &lt;/Fragment&gt;  );&#125;\n\n页面显示效果如下：\n\n但是这样做会导致一个问题。input框中的value是固定的，在页面中不能修改输入框中的内容。想要能够动态修改框中的内容，需要在input上绑定一个onChange函数（注意和原生js中onchange不同，此处C要大写）\n// 此处这样直接绑定handleInputChange会导致问题，后续会介绍render() &#123;  return (    &lt;Fragment&gt;      &lt;input        value=&#123;this.state.inputValue&#125;        onChange=&#123;this.handleInputChange&#125;      /&gt;      &lt;ul&gt;        &lt;li&gt;Learn React&lt;/li&gt;        &lt;li&gt;Learn Component&lt;/li&gt;      &lt;/ul&gt;    &lt;/Fragment&gt;  );&#125;\n\n在组件对应的类中添加handleInputChange函数\nhandleInputChange(e) &#123;    console.log(e.target.value);  &#125;\n\n这里的e.target指的是这个事件绑定的input元素，e.target.value指的就是input输入框中的内容\n到这里，看起来好像直接修改this.state中inputValue的值就可以了：\nhandleInputChange(e) &#123;  this.state.inputValue = e.target.value;&#125;\n\n不幸的是，输入框中的内容依然不能修改……\nReact中如果想要修改组件中定义的数据，需要使用setState()方法\nhandleInputChange(e) &#123;  // 数据不能直接改变  // this.state.inputValue = e.target.value;  // 要使用setState方法来改变组件中的数据  this.setState(&#123;    inputValue: e.target.value,  &#125;);&#125;\n\n现在setState()也用了，总该没问题了吧。保存！刷新页面！修改输入框中的内容！\n又报错了^_^\n\n呀？他说不能获取undefined的setState……我这个setState可是绑定在this上的……那我看看这个this到底是什么东西。打印一下！\nhandleInputChange(e) &#123;  console.log(this);\t// undefined  this.setState(&#123;    inputValue: e.target.value,  &#125;);&#125;\n\n这个this居然是undefined……\n看一下我们是如何绑定this的\nrender() &#123;  return (    &lt;Fragment&gt;      &lt;input        value=&#123;this.state.inputValue&#125;        onChange=&#123;this.handleInputChange&#125;      /&gt;      &lt;ul&gt;        &lt;li&gt;Learn React&lt;/li&gt;        &lt;li&gt;Learn Component&lt;/li&gt;      &lt;/ul&gt;    &lt;/Fragment&gt;  );&#125;\n\nonChange=&#123;this.handleInputChange&#125;中的this是render函数自身的this，指向组件实例。\n此时this.handleInputChange只是对于handleInputChange的一个引用，没有加()进行调用，所以在onChange事件触发时才会调用handleInputChange()方法。\n此时调用这个方法的应该是全局的window对象，this应该指向window，但是ES6中的class是严格模式，所以这时的this指向的就是undefined。\n想要将this绑定到当前的组件实例上，需要使用bind来改变this的指向。于是修改代码如下：\n  render() &#123;    return (      &lt;Fragment&gt;        &#123;/* 使用花括号将数据包裹起来 */&#125;        &lt;input          value=&#123;this.state.inputValue&#125;          onChange=&#123;this.handleInputChange.bind(this)&#125;        /&gt;        &lt;ul&gt;          &lt;li&gt;Learn React&lt;/li&gt;          &lt;li&gt;Learn Component&lt;/li&gt;        &lt;/ul&gt;      &lt;/Fragment&gt;    );  &#125;&#125;\n\nonChange=&#123;this.handleInputChange.bind(this)&#125;使this指向了当前的组件实例，再修改当前组件中的数据就可以了。\n此时我们就可以随意修改输入框中的数据了~\n\n实现TodoList新增删除功能处理完了输入框的输入问题，现在来解决列表新增删除的问题。\n新增之前我们在组件的state中定义了两种数据：input输入框的输入数据和&lt;ul&gt;列表的数据。现在默认输入框内容为空，list中存放原本写在&lt;li&gt;标签中的数据。页面上展示的列表应该由list中的内容来决定。\nconstructor(props) &#123;    super(props);    this.state = &#123;      inputValue: &quot;&quot;,      list: [&quot;Learn React&quot;, &quot;Learn Component&quot;],    &#125;;  &#125;\n\n现在我们希望根据list中的内容循环显示出&lt;li&gt;标签，把它们渲染到页面上。\n使用ES6中的map()方法对数组进行循环。map()方法接收一个函数作为参数，这个函数可以接收几个值：value（数组每一项的值），index（每一项的索引值）。使用map进行循环，每一次循环都需要return出一个结果。\n对于循环的每一个子项都应该有一个key值，这个key值对于每一个循环都应该是唯一的。添加key值会使react的性能更高。\n  render() &#123;    return (      &lt;Fragment&gt;        &#123;/* 使用花括号将数据包裹起来 */&#125;        &lt;input          value=&#123;this.state.inputValue&#125;          onChange=&#123;this.handleInputChange.bind(this)&#125;        /&gt;        &lt;ul&gt;          &#123;this.state.list.map((value, index) =&gt; &#123;            return &lt;li key=&#123;index&#125;&gt;&#123;value&#125;&lt;/li&gt;;          &#125;)&#125;        &lt;/ul&gt;      &lt;/Fragment&gt;    );  &#125;&#125;\n\n此时list数组中的内容便能循环渲染到页面上了。\n我们现在希望能够动态地添加列表项。当我们在输入框中按下回车时，将输入框中的内容添加到列表项中。为input标签添加onKeyUp事件，当按下enter键时，修改list数组中的数据即可。\nhandleKeyUp(e) &#123;  // 回车键的键盘码是13，按下回车代表输入完毕，添加列表项  // 由于函数handleInputChange,this.state.inputValue的值会随着输入框中内容的改变动态改变  // 获取this.state.inputValue就是获取输入框当前内容  // 添加后自动清空输入框  if (e.keyCode === 13) &#123;    const list = [...this.state.list, this.state.inputValue];    this.setState(&#123;      list: list,      inputValue: &quot;&quot;,    &#125;);  &#125;&#125;\n\n完成！效果如下：\n\n删除现在我们希望点击某一列表项，能够删除该项。思路很简单，给li标签添加onClick事件，绑定删除的函数即可。\n在删除的时候，如何能够知道要删除的是哪一项？我们之前遍历数组的时候使用了map()，map()方法中，对于数组每一项都有一个唯一的索引index，根据index值找到要删除的那一项，然后使用splice()方法即可~\nrender() &#123;  return (    &lt;Fragment&gt;      &lt;input        value=&#123;this.state.inputValue&#125;        onChange=&#123;this.handleInputChange.bind(this)&#125;        onKeyUp=&#123;this.handleKeyUp.bind(this)&#125;      /&gt;      &lt;ul&gt;        &#123;this.state.list.map((value, index) =&gt; &#123;          return (            &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;              &#123;value&#125;            &lt;/li&gt;          );        &#125;)&#125;      &lt;/ul&gt;    &lt;/Fragment&gt;  );&#125;\n\nhandleItemClick(index) &#123;  const list = [...this.state.list];  list.splice(index, 1);  this.setState(&#123;    list,  &#125;);&#125;\n\n更多JSX的语法细节bind(this)的优化在上面的代码中，每次监听事件都要调用bind(this)，这样导致页面中到处都是bind()。而且每次使用bind(this)，都会重新生成一个新的函数，也就是说，每次触发事件，都会生成一个新的函数，这样会导致性能降低。\n解决这个问题，可以将this的绑定放在constructor中\nconstructor(props) &#123;    super(props);    this.handleInputChange = this.handleInputChange.bind(this);    this.handleKeyUp = this.handleKeyUp.bind(this);        this.state = &#123;      inputValue: &quot;&quot;,      list: [&quot;Learn React&quot;, &quot;Learn Component&quot;],    &#125;;  &#125;\n\n这样，监听事件的时候就不需要再调用bind(this)了。\nrender() &#123;  return (    &lt;Fragment&gt;      &lt;input        value=&#123;this.state.inputValue&#125;        onChange=&#123;this.handleInputChange&#125;        onKeyUp=&#123;this.handleKeyUp&#125;      /&gt;      &lt;ul&gt;        &#123;this.state.list.map((value, index) =&gt; &#123;          return (            &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;              &#123;value&#125;            &lt;/li&gt;          );        &#125;)&#125;      &lt;/ul&gt;    &lt;/Fragment&gt;  );&#125;\n\n上面对onChange和onKeyUp进行了优化。对于onClick，因为每次需要传一个参数index进去，所以没有办法进行改写。\nJSX的简化之前我们直接在JSX中对数组进行循环，这样显得有些臃肿，我们可以把这部分提取出来，封装到一个函数中，然后直接在JSX中调用这个函数即可。\n// 封装为函数getListItems() &#123;  return this.state.list.map((value, index) =&gt; &#123;    return (      &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;        &#123;value&#125;      &lt;/li&gt;    );  &#125;);&#125;\n\n完整TodoList代码注意：使用代码需要提前创建React项目。请参考1.3节。\npublic/index.html:\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;    &lt;title&gt;Todo List&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\nsrc/index.js:\n// index.jsimport React from &quot;react&quot;;import ReactDom from &quot;react-dom&quot;;// 引入组件import TodoList from &quot;./TodoList&quot;;ReactDom.render(&lt;TodoList&gt;&lt;/TodoList&gt;, document.getElementById(&quot;root&quot;));\n\nsrc/TodoList.js:\n// TodoList组件，组件开头字母大写// 引入Fragment组件import React, &#123; Component, Fragment &#125; from &quot;react&quot;;class TodoList extends Component &#123;  // 定义组件中的数据  constructor(props) &#123;    // 接收参数props，传递给基类(Component)的构造函数    super(props);    this.handleInputChange = this.handleInputChange.bind(this);    this.handleKeyUp = this.handleKeyUp.bind(this);    // React中，定义组件的数据要放在this.state中    // inputValue定义input输入框中的数据    // list定义ul列表中的数据    this.state = &#123;      inputValue: &quot;&quot;,      list: [],    &#125;;  &#125;  handleInputChange(e) &#123;    // 这个函数的this默认是undefined    // 想要让this指向这个组件，需要在render函数中调用此方法时使用bind(this)    // console.log(e.target.value);    // 数据不能直接改变    // this.state.inputValue = e.target.value;    // 要使用setState方法来改变组件中的数据    // console.log(this);    this.setState(&#123;      inputValue: e.target.value,    &#125;);  &#125;  handleKeyUp(e) &#123;    // 回车键的键盘码是13，按下回车代表输入完毕，添加列表项    // 由于函数handleInputChange,this.state.inputValue的值会随着输入框中内容的改变动态改变    // 获取this.state.inputValue就是获取输入框当前内容    // 添加后自动清空输入框    if (e.keyCode === 13 &amp;&amp; e.target.value.trim() !== &quot;&quot;) &#123;      const list = [...this.state.list, this.state.inputValue.trim()];      this.setState(&#123;        list: list,        inputValue: &quot;&quot;,      &#125;);    &#125;  &#125;  handleItemClick(index) &#123;    const list = [...this.state.list];    list.splice(index, 1);    this.setState(&#123;      list,    &#125;);  &#125;  getListItems() &#123;    return this.state.list.map((value, index) =&gt; &#123;      return (        &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;          &#123;value&#125;        &lt;/li&gt;      );    &#125;);  &#125;  render() &#123;    // render一次只能渲染一个外部标签，想渲染多个，需要将标签放在一个div中。    // 但是这样的做法会导致dom中多出来一个div    // React16中提供了占位符组件Fragment    // 将所有组件放在Fragment中，不会在dom中添加其他的元素    return (      &lt;Fragment&gt;        &#123;/* 使用花括号将数据包裹起来 */&#125;        &lt;input          value=&#123;this.state.inputValue&#125;          onChange=&#123;this.handleInputChange&#125;          onKeyUp=&#123;this.handleKeyUp&#125;        /&gt;        &lt;ul&gt;&#123;this.getListItems()&#125;&lt;/ul&gt;      &lt;/Fragment&gt;    );  &#125;&#125;export default TodoList;\n\n","tags":["前端","React"]},{"title":"React组件与生命周期","url":"/2021/03/26/6.React%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"React组件与声明周期本节代码在前端——React基础基础上进行修改\n组件拆分与组件之间的传值·为什么要拆分组件：提高可维护性\n实践：将list中的item拆分出去，变成更小的组件\n当前getListItems()方法返回的是&lt;li&gt;标签，我们现在要做的是把返回的内容拆分为一个更小的组件。\n只需要将其中的代码重新写到TodoItem.js中，然后在TodoList.js中引入这个组件，以标签的形式使用这个组件即可。\n// TodoItem组件 TodoItem.jsimport React, &#123; Component &#125; from &quot;react&quot;;class TodoItem extends Component &#123;  render() &#123;    return &lt;li&gt;this is an item&lt;/li&gt;;  &#125;&#125;export default TodoItem;\n\n但是我们需要让TodoItem这个组件获取到我们要渲染的数据。此时我们需要找到TodoItem的父级组件，让这个父级组件告诉TodoItem，需要渲染的是什么内容。\n此时，需要使用属性的形式，来告诉子组件需要展示什么内容。\n在父组件引用的子组件标签中，可以任意命名一个属性，通过这个属性的值来给子组件传递一些内容。\n子组件需要使用this.props.属性名来接收父组件传递过来的值。\ngetListItems() &#123;  return this.state.list.map((value, index) =&gt; &#123;    // 此处属性名为content，向子组件TodoItem传递value这个值    return &lt;TodoItem content=&#123;value&#125;&gt;&lt;/TodoItem&gt;;  &#125;);&#125;\n\n// TodoItem组件 TodoItem.jsimport React, &#123; Component &#125; from &quot;react&quot;;class TodoItem extends Component &#123;  render() &#123;    // 使用this.props接收父组件传递过来的内容，属性名为content    return &lt;li&gt;&#123;this.props.content&#125;&lt;/li&gt;;  &#125;&#125;export default TodoItem;\n\n小结：\n父子组件的概念：在一个组件中引用了另一个组件，这两个组件就构成了父子关系。\n父组件通过属性的形式向子组件传值。\n子组件通过this.props的属性，从父组件接收传递过来的值。\n现在继续来拆分。\n拆分出上面的TodoItem组件后，产生了一个问题。我们现在点击列表项无法删除这个列表项了。因为此时组件内的&lt;li&gt;标签上并没有绑定onClick事件。\n此时要注意，我们不能往子组件标签上绑定onClick事件，也就是不能往&lt;TodoItem&gt;标签上绑定事件。我们需要做的是进入到子组件里面，对里面的&lt;li&gt;标签进行事件绑定。\nreturn &lt;li onClick=&#123;this.handleItemClick.bind(this)&#125;&gt;&#123;this.props.content&#125;&lt;/li&gt;;\n\n新的问题又来了。我们要调用的handleItemClick()方法，需要修改的是父组件中的this.state.list的数据。\nReact中父组件除了可以以属性的形式向子组件传递数据，还可以以属性的形式向子组件传递方法。\n此时我们把父组件中的handleItemClick()方法传递给子组件。delFunction=&#123;this.handleItemClick&#125;代表在创建TodoItem子组件时，将handleItemClick方法一同传递给子组件。子组件要做的就是调用这个传递过来的delFunction方法。\n子组件调用父组件传递过来的方法，同样使用this.props进行调用。使用this.props.delFunction()即可。\n// TodoList.js// 为子组件添加传递的方法delFunction  getListItems() &#123;    return this.state.list.map((value, index) =&gt; &#123;      return (        &lt;TodoItem          content=&#123;value&#125;          key=&#123;index&#125;          delFunction=&#123;this.handleItemClick&#125;        &gt;&lt;/TodoItem&gt;      );    &#125;);  &#125;\n\n// TodoItem组件 TodoItem.jsimport React, &#123; Component &#125; from &quot;react&quot;;class TodoItem extends Component &#123;  constructor(props) &#123;    super(props);    this.handleItemClick = this.handleItemClick.bind(this);  &#125;  handleItemClick(e) &#123;    // 改变父组件中的list数据    this.props.delFunction();  &#125;  render() &#123;    return &lt;li onClick=&#123;this.handleItemClick&#125;&gt;&#123;this.props.content&#125;&lt;/li&gt;;  &#125;&#125;export default TodoItem;\n\n如果只是这样写，会报错。因为此时调用的delFunction中，需要修改的是this.state.list的数据，而在子组件中执行，this指向的是当前类的实例，在当前组件中并不存在state.list，所以会报错。\n为了解决这个问题，我们需要在父组件中绑定this为父组件实例，添加this.handleItemClick = this.handleItemClick.bind(this);\n// TodoList的构造函数constructor(props) &#123;  super(props);  this.handleInputChange = this.handleInputChange.bind(this);  this.handleKeyUp = this.handleKeyUp.bind(this);  this.handleItemClick = this.handleItemClick.bind(this);    this.state = &#123;    inputValue: &quot;&quot;,    list: [],  &#125;;&#125;\n\n\n\n但是，删除某一列表项需要获取到该项的index值，我们之前定义的handleItemClick()方法中也确实传入了一个index参数。\n// 之前定义的handleItemClick  handleItemClick(index) &#123;    const list = [...this.state.list];    list.splice(index, 1);    this.setState(&#123;      list,    &#125;);  &#125;\n\n所以在子组件中，需要获取到每项的index值。我们在父组件中遍历数组并且创建TodoItem组件的时候，就可以通过属性的方式把index传递给子组件。（index=&#123;index&#125;）\n// TodoList.js  getListItems() &#123;  return this.state.list.map((value, index) =&gt; &#123;    //   return (    //     &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;    //       &#123;value&#125;    //     &lt;/li&gt;    //   );    // 此处属性名为content，向子组件TodoItem传递value这个值    return (      &lt;TodoItem        content=&#123;value&#125;        key=&#123;index&#125;        index=&#123;index&#125;        delFunction=&#123;this.handleItemClick&#125;      &gt;&lt;/TodoItem&gt;    );  &#125;);&#125;\n\n子组件通过this.props.index就可以获取到index属性值了~\n// TodoItem组件 TodoItem.jsimport React, &#123; Component &#125; from &quot;react&quot;;class TodoItem extends Component &#123;  constructor(props) &#123;    super(props);    this.handleItemClick = this.handleItemClick.bind(this);  &#125;  handleItemClick(e) &#123;    // 改变父组件中的list数据，获取到父组件传递的index值    this.props.delFunction(this.props.index);  &#125;  render() &#123;    return &lt;li onClick=&#123;this.handleItemClick&#125;&gt;&#123;this.props.content&#125;&lt;/li&gt;;  &#125;&#125;export default TodoItem;\n\n★★★小结：\n父组件通过属性形式和子组件进行通信，可以传递值/方法；\n子组件和父组件进行通信，需要调用父组件传递过来的方法。；\n子组件调用父组件的方法时，要在父组件传递方法的过程中，变更方法的作用域，this绑定在父组件中，否则传递到子组件后，this的指向会出现问题。\n拆分组件后的完整代码目录结构如下图所示：\n\npublic/index.html\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;    &lt;title&gt;Orla React&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\nsrc/index.js\n// index.jsimport React from &quot;react&quot;;import ReactDom from &quot;react-dom&quot;;// 引入组件import TodoList from &quot;./TodoList&quot;;ReactDom.render(&lt;TodoList&gt;&lt;/TodoList&gt;, document.getElementById(&quot;root&quot;));\n\nsrc/TodoList.js\n// TodoList组件，组件开头字母大写// 引入Fragment组件import React, &#123; Component, Fragment &#125; from &quot;react&quot;;import TodoItem from &quot;./TodoItem&quot;;class TodoList extends Component &#123;  // 定义组件中的数据  constructor(props) &#123;    // 接收参数props，传递给基类(Component)的构造函数    super(props);    this.handleInputChange = this.handleInputChange.bind(this);    this.handleKeyUp = this.handleKeyUp.bind(this);    this.handleItemClick = this.handleItemClick.bind(this);    // React中，定义组件的数据要放在this.state中    // inputValue定义input输入框中的数据    // list定义ul列表中的数据    this.state = &#123;      inputValue: &quot;&quot;,      list: [],    &#125;;  &#125;  handleInputChange(e) &#123;    // 这个函数的this默认是undefined    // 想要让this指向这个组件，需要在render函数中调用此方法时使用bind(this)    // console.log(e.target.value);    // 数据不能直接改变    // this.state.inputValue = e.target.value;    // 要使用setState方法来改变组件中的数据    // console.log(this);    this.setState(&#123;      inputValue: e.target.value,    &#125;);  &#125;  handleKeyUp(e) &#123;    // 回车键的键盘码是13，按下回车代表输入完毕，添加列表项    // 由于函数handleInputChange,this.state.inputValue的值会随着输入框中内容的改变动态改变    // 获取this.state.inputValue就是获取输入框当前内容    // 添加后自动清空输入框    if (e.keyCode === 13 &amp;&amp; e.target.value.trim() !== &quot;&quot;) &#123;      const list = [...this.state.list, this.state.inputValue.trim()];      this.setState(&#123;        list: list,        inputValue: &quot;&quot;,      &#125;);    &#125;  &#125;  handleItemClick(index) &#123;    const list = [...this.state.list];    list.splice(index, 1);    this.setState(&#123;      list,    &#125;);  &#125;  getListItems() &#123;    return this.state.list.map((value, index) =&gt; &#123;      //   return (      //     &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;      //       &#123;value&#125;      //     &lt;/li&gt;      //   );      // 此处属性名为content，向子组件TodoItem传递value这个值      return (        &lt;TodoItem          content=&#123;value&#125;          key=&#123;index&#125;          index=&#123;index&#125;          delFunction=&#123;this.handleItemClick&#125;        &gt;&lt;/TodoItem&gt;      );    &#125;);  &#125;  render() &#123;    // render一次只能渲染一个外部标签，想渲染多个，需要将标签放在一个div中。    // 但是这样的做法会导致dom中多出来一个div    // React16中提供了占位符组件Fragment    // 将所有组件放在Fragment中，不会在dom中添加其他的元素    return (      &lt;Fragment&gt;        &#123;/* 使用花括号将数据包裹起来 */&#125;        &lt;input          value=&#123;this.state.inputValue&#125;          onChange=&#123;this.handleInputChange&#125;          onKeyUp=&#123;this.handleKeyUp&#125;        /&gt;        &lt;ul&gt;&#123;this.getListItems()&#125;&lt;/ul&gt;      &lt;/Fragment&gt;    );  &#125;&#125;export default TodoList;\n\nsrc/TodoItem.js\n// TodoItem组件 TodoItem.jsimport React, &#123; Component &#125; from &quot;react&quot;;class TodoItem extends Component &#123;  constructor(props) &#123;    super(props);    this.handleItemClick = this.handleItemClick.bind(this);  &#125;  handleItemClick(e) &#123;    // 改变父组件中的list数据，获取到父组件传递的index值    // ES6解构赋值，简化写法。和this.props.delFunction(this.props.index);等价    const &#123; delFunction, index &#125; = this.props;    delFunction(index);  &#125;  render() &#123;    // 使用this.props接收父组件传递过来的内容，属性名为content    // ES6解构赋值简化写法    // const &#123; content &#125; = this.props;    // return &lt;li&gt;&#123;content&#125;&lt;/li&gt;;    return &lt;li onClick=&#123;this.handleItemClick&#125;&gt;&#123;this.props.content&#125;&lt;/li&gt;;  &#125;&#125;export default TodoItem;\n\nReact生命周期React核心特性总结React采用的是声明式开发模式，不需要我们对DOM进行任何操作，只需要定义好JSX模板和数据，数据发生变化时，页面DOM会自动发生变化。从上述TodoList的开发中可见一斑。\nReact可以和其他框架并存。有一套解耦的机制。\n组件化。不用多说了吧，都是组件。\n单向数据流。父组件可以改变子组件的数据，但是子组件一定不能直接改变父组件的数据。\n函数式编程。每个组件都由很多函数构成，方便自动化测试。\nprops, state与render函数props: 属性。父组件通过属性向子组件传递参数。\nstate: 组件中的数据。\nrender函数: 用来渲染组件中的内容。\n这三者之间存在一定的联系：\n当组件初次创建的时候，render函数会被执行一次。\n当state数据发生变更的时候，render函数会被重新执行。\n当props数据发生变更的时候，接收props的子组件的render函数会被重新执行。\n当父组件的render函数被运行时，子组件的render函数都将被重新运行。\n用代码来举例：\n依然是创建一个React项目。页面上显示一个button和一个数字，每当我们点击这个button，数字就会+1。\n\npublic/index.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;    &lt;title&gt;props-state-render&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\nsrc/counter.js\nimport React, &#123; Component &#125; from &quot;react&quot;;class Counter extends Component &#123;  constructor(props) &#123;    super(props);    this.handleClick = this.handleClick.bind(this);    this.state = &#123;      number: 1,    &#125;;  &#125;  handleClick() &#123;    const newNumber = this.state.number + 1;    this.setState(&#123;      number: newNumber,    &#125;);  &#125;  render() &#123;    console.log(&quot;counter render&quot;);    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;点击+1&lt;/button&gt;        &lt;div&gt;&#123;this.state.number&#125;&lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;export default Counter;\n\n在这个组件中，每次调用render函数就会在控制台打印”counter render”。\n来看效果：\n\n从这里可以看出，当组件初次创建的时候，render函数会被执行一次。当state数据发生变更的时候，render函数会被重新执行。\n那么当props改变时，render函数又会如何执行？\n要用props，需要创建一个子组件，并在父组件中引用它。在子组件的render函数中打印”props change”。\nsrc/child.js\n// 子组件child.jsimport React, &#123; Component &#125; from &quot;react&quot;;class Child extends Component &#123;  render() &#123;    // props数据发生改变，子组件的render函数就会重新执行    console.log(&quot;props change&quot;);    return &lt;div&gt;&#123;this.props.number&#125;&lt;/div&gt;;  &#125;&#125;export default Child;\n\nsrc/counter.js\n// 父组件counter.jsimport React, &#123; Component &#125; from &quot;react&quot;;import Child from &quot;./child&quot;;class Counter extends Component &#123;  constructor(props) &#123;    super(props);    this.handleClick = this.handleClick.bind(this);    this.state = &#123;      number: 1,    &#125;;  &#125;  handleClick() &#123;    const newNumber = this.state.number + 1;    this.setState(&#123;      number: newNumber,    &#125;);  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;点击+1&lt;/button&gt;        &lt;Child number=&#123;this.state.number&#125;&gt;&lt;/Child&gt;      &lt;/div&gt;    );  &#125;&#125;export default Counter;\n\n实现效果：\n\n当初次使用子组件时，子组件的render函数会被执行一次。每当props中的数据发生改变时，接收props的子组件的render也会重新执行。\nReact中ref的使用React是一个数据驱动的框架，我们想实现一个功能的时候，不要直接去操作DOM，而是直接操作数据，数据变化，页面就会随之改变。\n但是在某些特殊场景下，我们依然需要对React中某些组件的DOM做一些操作。在React中操作DOM，就需要使用ref。（不推荐使用ref）\n拿上一小节的counter组件举例。现在想实现这样一个功能：当我点击按钮时，我想知道这个按钮距离浏览器顶部的距离是多少。\n思考一下，要想获取到button按钮距离浏览器顶部的距离，那我们就必须获取到button的这个DOM结点，React是数据驱动的，不直接操作DOM，无法帮我们计算距离这样的东西。所以这里需要通过原生的DOM计算来获取到这个距离。\n这时候，ref属性就派上用场了。\n我们可以找到JSX中对应的那个button按钮，在这个按钮上增加一个ref属性，这个属性一般等于一个函数，这个函数接收的参数就是button这个JSX标签真实对应的DOM。将这个参数赋值给当前组建的this之中。我们通过this就可以直接拿到这个DOM结点了。\n看代码：\n// counter.jsimport React, &#123; Component &#125; from &quot;react&quot;;import Child from &quot;./child&quot;;class Counter extends Component &#123;  constructor(props) &#123;    super(props);    this.handleClick = this.handleClick.bind(this);    this.state = &#123;      number: 1,    &#125;;  &#125;  handleClick() &#123;    // 获取button对应的DOM结点    console.log(this.buttonElem);    const newNumber = this.state.number + 1;    this.setState(&#123;      number: newNumber,    &#125;);  &#125;  render() &#123;    // 给button添加ref属性    return (      &lt;div&gt;        &lt;button          onClick=&#123;this.handleClick&#125;          ref=&#123;(button) =&gt; &#123;            this.buttonElem = button;          &#125;&#125;        &gt;          点击+1        &lt;/button&gt;        &lt;Child number=&#123;this.state.number&#125;&gt;&lt;/Child&gt;      &lt;/div&gt;    );  &#125;&#125;export default Counter;\n\n这样通过this.buttonElem我们就拿到了button这个JSX标签真实对应的DOM。\n\n获取到这个DOM结点之后，就可以调用原生属性了~  使用this.buttonElem.clientTop就可以获取到距离顶部的距离。\n现在我们知道了ref的作用：ref可以帮助我们获取JSX标签对应的原生DOM结点\n现在有一个问题。我们把ref放到了标签上可以获取到对应的DOM结点。那如果把ref属性放到组件上呢？\n注意ref中的函数接收参数的名字要和标签相同。\n// counter.js// 给Child组件添加ref属性import React, &#123; Component &#125; from &quot;react&quot;;import Child from &quot;./child&quot;;class Counter extends Component &#123;  constructor(props) &#123;    super(props);    this.handleClick = this.handleClick.bind(this);    this.state = &#123;      number: 1,    &#125;;  &#125;  handleClick() &#123;    // 获取button对应的DOM结点    console.log(this.childElem);    const newNumber = this.state.number + 1;    this.setState(&#123;      number: newNumber,    &#125;);  &#125;  render() &#123;    // 给子组件Child添加ref属性    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;点击+1&lt;/button&gt;        &lt;Child          number=&#123;this.state.number&#125;          ref=&#123;(child) =&gt; &#123;            this.childElem = child;          &#125;&#125;        &gt;&lt;/Child&gt;      &lt;/div&gt;    );  &#125;&#125;export default Counter;\n\n此时打印的是子组件对应的组件实例。\n\n小结：\nref写在JSX的标签上，获取的是对应的DOM结点；\nref写在组件标签上，获取的是组件的js实例。\n异步的setStatesetState有一个很重要的特点：它的执行是异步的。\n举个例子。\n在计数器的基础上，修改代码，显示数字的地方使用div标签，使用ref获取到这个div对应的DOM元素，点击按钮使用setState修改其中的数据。然后在setState之前打印一次div的innerHTML，在setState之后再打印一次div的innerHTML。代码如下：\n// counter.jsimport React, &#123; Component &#125; from &quot;react&quot;;class Counter extends Component &#123;  constructor(props) &#123;    super(props);    this.handleClick = this.handleClick.bind(this);    this.state = &#123;      number: 1,    &#125;;  &#125;  handleClick() &#123;    // setState之前获取div对应的DOM结点中的内容    console.log(this.divElem.innerHTML);    const newNumber = this.state.number + 1;    this.setState(&#123;      number: newNumber,    &#125;);    // setState之后获取div对应的DOM结点中的内容    console.log(this.divElem.innerHTML);  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;点击+1&lt;/button&gt;        &lt;div          ref=&#123;(div) =&gt; &#123;            this.divElem = div;          &#125;&#125;        &gt;          &#123;this.state.number&#125;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;export default Counter;\n\n按理来说，setState之前，number的值并未被修改。初始number值为1，那么最开始应该输出1，调用setState之后，number=number + 1，再次输出number的值应该为2。\n运行一下看看。\n\n两次输出的结果居然一样。\n这里的原因就在于，**setState是异步执行的**。setState还没执行，后面的代码可能就先执行了。\n想解决这个问题，可以将setState换种写法。\n之前我们写setState，都是让其接收一个对象。\nthis.setState(&#123;     number: newNumber,&#125;);\n\n它也可以接收一个函数，在这个函数中return一个对象。这两种写法其实是等价的\nthis.setState(() =&gt; &#123;  return &#123;    number: newNumber,  &#125;;&#125;);\n\n这样写的好处是，我们可以在setState中写第二个参数，第二个参数也是一个函数，这个函数在setState将数据改变之后才会执行。\n修改代码如下。\nimport React, &#123; Component &#125; from &quot;react&quot;;class Counter extends Component &#123;  constructor(props) &#123;    super(props);    this.handleClick = this.handleClick.bind(this);    this.state = &#123;      number: 1,    &#125;;  &#125;  handleClick() &#123;    console.log(this.divElem.innerHTML);    const newNumber = this.state.number + 1;    // 这里修改setState的写法，并传入第二个参数    this.setState(      () =&gt; &#123;        return &#123;          number: newNumber,        &#125;;      &#125;,      () =&gt; &#123;        console.log(this.divElem.innerHTML);      &#125;    );  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;点击+1&lt;/button&gt;        &lt;div          ref=&#123;(div) =&gt; &#123;            this.divElem = div;          &#125;&#125;        &gt;          &#123;this.state.number&#125;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;export default Counter;\n\n这样，第二次输出的就是修改后的number值了。\n\nReact组件的生命周期函数先下个定义：在React中，生命周期函数是组件在某一时刻会自动执行的函数。\n之前使用的render()函数就是一个生命周期函数，它在组件的数据发生变化时自动执行。\n首先来看一下，React组件在展示页面时会分为几个周期。每个周期会有一些生命周期函数自动执行。\n\n① Initialization：组件初始化阶段。设置一些props/state数据。没有用到生命周期函数。\n② Mounting：页面挂载阶段。将数据展示到HTML页面上。三个生命周期函数函数执行顺序：componentWillMount() –&gt; render() –&gt; componentDidMount()，即挂载前准备–&gt;挂载–&gt;挂载完成。只有在组件第一次渲染到页面中时，才会执行Mounting这一阶段。后续修改数据，页面重新渲染，Mounting也不会重新执行。\n③ Updation：数据更新阶段。组件中的数据发生变化，不会重新进行Mounting，而是执行Updation这一阶段。\n​    这一阶段的执行流程分为两类。一类是props发生变化时的执行流程；另一类是states发生变化时的执行流程。\n④ Unmounting：组件销毁阶段。当组件即将从页面中移除时，componentWillUnmount()会自动执行。\n","tags":["前端","React"]}]