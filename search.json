[{"title":"ES6（一）let & const","url":"/2021/03/18/ES6%EF%BC%88%E4%B8%80%EF%BC%89let%20&%20const/","content":"ES6 let&amp;const命令let和const是ES6中新增的两个声明变量的命令。\n基本用法和var相同，区别在于let和const声明的变量只在声明的代码块内有效。\nif (true) &#123;    let myName = &quot;Orla&quot;;&#125;console.log(myName);\t\t// Uncaught ReferenceError: myName is not defined\n\nlet代替var来声明变量，const代替var来声明常量。\nvar和let声明的是变量，变量初始化后还可以重新赋值；const声明的常量一旦初始化，就不能重新赋值，否则会报错。（实际上不是常量的值不可以改变，而是指向的内存地址不可以改变，此处针对引用数据类型）\nconst person = &#123;    name: &quot;Orla&quot;,    age: 20,&#125;;person.name = &quot;Zhangsan&quot;;console.log(person);\n\n\n\n\nlet&amp;const与var的区别不存在变量提升var命令存在变量提升现象，即变量可以在声明之前使用，其值为undefined。但这并不符合逻辑。let&amp;const消除了这种现象，变量必须在声明之后才能使用。\nconsole.log(a); // undefinedvar a = 10;console.log(b); // 报错 Uncaught ReferenceError: Cannot access &#x27;b&#x27; before initializationlet b = 20;\n\n\n\n重复声明let/const不允许在相同作用域内重复声明同一个变量。\n暂时性死区(TDZ)只要作用域中存在let/const，它们所声明的变量/常量就自动“绑定”这个区域，不再受到外部作用域的影响。只要在声明语句之前使用let/const声明的变量，就会报错。简言之，使用let/const命令声明变量之前，该变量都是不可用的，这就被称作暂时性死区。\nlet a = 20;function func() &#123;    // let不存在变量提升，let声明的a与该区域绑定，不受外部影响    console.log(a); // Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization    let a = 10;&#125;func();\n\n暂时性死区也意味着typeof不再是一个百分百安全的操作。\n&#123;\ttypeof a; // Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization    let a = [];&#125;\n\n\n\nwindow对象的属性和方法全局作用域中，var声明的变量以及通过function声明的函数，会自动变成window对象的属性和方法。let、const不会。\nvar a = 10;let b = 20;const c = 30;function add() &#123;&#125;console.log(window.a); // 10console.log(window.b); // undefinedconsole.log(window.c); // undefinedconsole.log(window.add === add); // true\n\n\n\n块级作用域以for循环为例。如果使用let，i只在for循环体内有效，在循环体外引用就会报错。\nfor (let i = 0; i &lt; 10; i++) &#123;  // ...&#125;console.log(i);// ReferenceError: i is not defined\n\n如果使用var，则会输出10（因为ES5中没有块级作用域）。\n// 变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i// 每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i// 也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。var a = [];for (var i = 0; i &lt; 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[8](); // 10\n\n\n\n如果使用let，声明的变量仅在块级作用域内有效。\n// 变量i是let声明的，当前的i只在本轮循环有效// 每一次循环的i其实都是一个新的变量// for循环的计数器就很适合用let，不会出现全局变量改变的情况var a = [];for (let i = 0; i &lt; 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[8](); // 8\n\n\n\nfor循环有一个特别之处:循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。\nfor (let i = 0; i &lt; 3; i++) &#123;  let i = &#x27;abc&#x27;;  console.log(i);&#125;// abc// abc// abc\n\n","tags":["ES6"]}]