[{"title":"ES6（一）let & const","url":"/2021/03/18/ES6%EF%BC%88%E4%B8%80%EF%BC%89let%20&%20const/","content":"ES6 let&amp;const命令let和const是ES6中新增的两个声明变量的命令。\n基本用法和var相同，区别在于let和const声明的变量只在声明的代码块内有效。\nif (true) &#123;    let myName = &quot;Orla&quot;;&#125;console.log(myName);\t\t// Uncaught ReferenceError: myName is not defined\n\nlet代替var来声明变量，const代替var来声明常量。\nvar和let声明的是变量，变量初始化后还可以重新赋值；const声明的常量一旦初始化，就不能重新赋值，否则会报错。（实际上不是常量的值不可以改变，而是指向的内存地址不可以改变，此处针对引用数据类型）\nconst person = &#123;    name: &quot;Orla&quot;,    age: 20,&#125;;person.name = &quot;Zhangsan&quot;;console.log(person);\n\n\n\n\nlet&amp;const与var的区别不存在变量提升var命令存在变量提升现象，即变量可以在声明之前使用，其值为undefined。但这并不符合逻辑。let&amp;const消除了这种现象，变量必须在声明之后才能使用。\nconsole.log(a); // undefinedvar a = 10;console.log(b); // 报错 Uncaught ReferenceError: Cannot access &#x27;b&#x27; before initializationlet b = 20;\n\n\n\n重复声明let/const不允许在相同作用域内重复声明同一个变量。\n暂时性死区(TDZ)只要作用域中存在let/const，它们所声明的变量/常量就自动“绑定”这个区域，不再受到外部作用域的影响。只要在声明语句之前使用let/const声明的变量，就会报错。简言之，使用let/const命令声明变量之前，该变量都是不可用的，这就被称作暂时性死区。\nlet a = 20;function func() &#123;    // let不存在变量提升，let声明的a与该区域绑定，不受外部影响    console.log(a); // Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization    let a = 10;&#125;func();\n\n暂时性死区也意味着typeof不再是一个百分百安全的操作。\n&#123;\ttypeof a; // Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization    let a = [];&#125;\n\n\n\nwindow对象的属性和方法全局作用域中，var声明的变量以及通过function声明的函数，会自动变成window对象的属性和方法。let、const不会。\nvar a = 10;let b = 20;const c = 30;function add() &#123;&#125;console.log(window.a); // 10console.log(window.b); // undefinedconsole.log(window.c); // undefinedconsole.log(window.add === add); // true\n\n\n\n块级作用域以for循环为例。如果使用let，i只在for循环体内有效，在循环体外引用就会报错。\nfor (let i = 0; i &lt; 10; i++) &#123;  // ...&#125;console.log(i);// ReferenceError: i is not defined\n\n如果使用var，则会输出10（因为ES5中没有块级作用域）。\n// 变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i// 每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i// 也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。var a = [];for (var i = 0; i &lt; 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[8](); // 10\n\n\n\n如果使用let，声明的变量仅在块级作用域内有效。\n// 变量i是let声明的，当前的i只在本轮循环有效// 每一次循环的i其实都是一个新的变量// for循环的计数器就很适合用let，不会出现全局变量改变的情况var a = [];for (let i = 0; i &lt; 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[8](); // 8\n\n\n\nfor循环有一个特别之处:循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。\nfor (let i = 0; i &lt; 3; i++) &#123;  let i = &#x27;abc&#x27;;  console.log(i);&#125;// abc// abc// abc\n\n","tags":["ES6"]},{"title":"前端——单行/多行文字溢出省略","url":"/2021/03/23/%E5%89%8D%E7%AB%AF-%E5%8D%95%E8%A1%8C%E5%A4%9A%E8%A1%8C%E6%96%87%E5%AD%97%E6%BA%A2%E5%87%BA%E7%9C%81%E7%95%A5/","content":"前端——单行/多行文字溢出省略单行文字省略样式代码，添加对应的class即可.text-ellipsis&#123;    overflow: hidden;    text-overflow: ellipsis;    white-space: nowrap;&#125;\n\n示例：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;单行文字溢出省略&lt;/title&gt;    &lt;style&gt;      * &#123;        margin: 0;        padding: 0;      &#125;      .container &#123;        margin: 20px auto;        width: 300px;        border: 1px solid #eee;      &#125;      li &#123;        display: block;        list-style: none;        color: rgb(158, 152, 152);        border-bottom: 1px dashed rgb(158, 152, 152);        margin: 10px;      &#125;      .text-ellipsis &#123;        overflow: hidden;        text-overflow: ellipsis;        white-space: nowrap;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;ul&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n效果：\n多行文字省略样式代码，添加对应的class即可.multiline-ellipsis&#123;    overflow: hidden;    text-overflow: ellipsis;    display: -webkit-box;    /* 设置文字显示行数 */    -webkit-line-clamp: 2;    -webkit-box-orient: vertical;    white-space: normal !important;    word-wrap: break-word;&#125;\n\n示例：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;多行文字溢出省略&lt;/title&gt;    &lt;style&gt;      .container &#123;        width: 300px;        margin: 20px auto;        border: 1px solid rgb(155, 147, 147);      &#125;      .multiline-ellipsis &#123;        overflow: hidden;        text-overflow: ellipsis;        display: -webkit-box;        /* 设置文字显示行数 */        -webkit-line-clamp: 2;        -webkit-box-orient: vertical;        white-space: normal !important;        word-wrap: break-word;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;h3&gt;岳阳楼记&lt;/h3&gt;      &lt;p class=&quot;multiline-ellipsis&quot;&gt;        庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴，乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上，属予作文以记之。&lt;br /&gt;        予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯，朝晖夕阴，气象万千，此则岳阳楼之大观也，前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？&lt;br /&gt;        若夫淫雨霏霏，连月不开，阴风怒号，浊浪排空，日星隐曜，山岳潜形，商旅不行，樯倾楫摧，薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣。&lt;br /&gt;        至若春和景明，波澜不惊，上下天光，一碧万顷，沙鸥翔集，锦鳞游泳，岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧，渔歌互答，此乐何极！登斯楼也，则有心旷神怡，宠辱偕忘，把酒临风，其喜洋洋者矣。&lt;br /&gt;        嗟夫！予尝求古仁人之心，或异二者之为，何哉？不以物喜，不以己悲，居庙堂之高则忧其民，处江湖之远则忧其君。是进亦忧，退亦忧。然则何时而乐耶？其必曰“先天下之忧而忧，后天下之乐而乐”乎！噫！微斯人，吾谁与归？&lt;br /&gt;        时六年九月十五日。      &lt;/p&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n效果：\n","tags":["前端","css"]},{"title":"前端——移动端事件","url":"/2021/03/19/%E5%89%8D%E7%AB%AF-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6/","content":"移动端事件移动端事件一共有三类：触摸事件、手势(gesture)事件以及传感器(sensor)事件。其中，触摸事件又可分为touch事件和pointer事件。\n触摸事件touch事件touch分类touch事件可分为touchstart, touchmove, touchend和touchcancel四种。\ntouchstart：手指触摸到屏幕时会触发\ntouchmove：手指按在屏幕上并移动时触发\ntouchend：手指离开屏幕时触发\ntouchcancel：通常是系统级的事件触发。比如正在滑动屏幕时有电话打进来，页面切换到了通话界面，此时就会触发touchcancel事件。\n举个栗子：\n&lt;!-- 页面上存在一个div --&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;\n\n/* 为其设置样式 */#box &#123;  width: 150px;  height: 150px;  background-color: rgb(236, 148, 148);  margin: 20px auto;  color: #fff;  font-weight: bold;  text-align: center;  line-height: 150px;&#125;\n\nconst box = document.getElementById(&quot;box&quot;);// 绑定三个touch事件box.addEventListener(&quot;touchstart&quot;, handleStart, false);box.addEventListener(&quot;touchmove&quot;, handleMove, false);box.addEventListener(&quot;touchend&quot;, handleEnd, false);function handleStart() &#123;  box.innerText = &quot;我被点了&quot;;  console.log(&quot;touchStart&quot;);&#125;function handleMove() &#123;  box.innerText = &quot;正在移动...&quot;;  console.log(&quot;touchMove&quot;);&#125;function handleEnd() &#123;  box.innerText = &quot;松开了！&quot;;  console.log(&quot;touchEnd&quot;);&#125;\n\n当手指在盒子内部点击盒子、移动手指、松开手指时，效果如下：\n\n当手指在盒子外部点击、移动、松开时，不会触发事件，即使手指在这个过程中移动到了盒子上：\n\n当手指在盒子内部点击，并滑出盒子范围后，事件依然会触发：\n\ntouch事件的event对象每个touch事件都会有event对象，每次touch的信息都会包含在event对象中。\n将上面的代码中的event打印出来。\nfunction handleStart(ev) &#123;        box.innerText = &quot;我被点了&quot;;        console.log(&quot;touchStart&quot;, ev);      &#125;      function handleMove(ev) &#123;        box.innerText = &quot;正在移动...&quot;;        console.log(&quot;touchMove&quot;, ev);      &#125;      function handleEnd(ev) &#123;        box.innerText = &quot;松开了！&quot;;        console.log(&quot;touchEnd&quot;, ev);      &#125;\n\n以touchstart中的event为例：\n\n我们这里重点关注三个属性：changedTouches, targetTouches和touches。\n这三个属性几乎包含了我们手指点击屏幕时所有信息。这三个属性其实都是类数组对象，具有下标和length，但是没有数组的方法。\ntouches的length代表触摸屏幕的手指数，有多少根手指触摸屏幕，length就是多少。\ntargetTouches的length代表触摸事件绑定元素的手指数，如果手指落在该绑定元素的范围外，则不计入length。\nchangedTouches的length代表触摸事件绑定元素并移动的手指数。注意：假设只有一根手指点击屏幕。当触发touchend时，代表手指离开屏幕时的事件被触发，此时没有手指触摸屏幕，所以此时的touches和targetTouches的length均为0。但是可以检测到手指离开了屏幕，changedTouches的length为1。\n所以推荐使用changedTouches来获取手指触摸时的信息。防止其他属性获取不到touchend事件的相关信息。\nfunction handleEnd(ev) &#123;        box.innerText = &quot;松开了！&quot;;        console.log(&quot;touchEnd&quot;, ev);        console.log(ev.changedTouches);      &#125;\n\n此时输出的就是我们触摸屏幕时的一些信息，包含触摸点的坐标等。这样我们就可以方便地获取到这些信息。\n\n一个小案例：图标拖拽   const backtop = document.getElementById(&quot;backtop&quot;);   // 存放每次开始移动时的手指坐标   const startPoint = &#123;&#125;;   // 实现拖动的函数drag()   // element是绑定的元素   // options是用户传入的参数，&#123;x: true/false, y: true/false&#125;，代表x和y方向上是否允许移动   function drag(element, options) &#123;     options.x = typeof options.x === undefined ? false : options.x;     options.y = typeof options.y === undefined ? false : options.y;     // x, y方向均不允许移动     if (!options.x &amp;&amp; !options.y) return;     const curPoint = &#123;       x: 0,       y: 0,     &#125;;     // 添加touch事件监听     element.addEventListener(&quot;touchstart&quot;, handleStart, false);     element.addEventListener(&quot;touchmove&quot;, handleMove, false);     element.addEventListener(&quot;touchend&quot;, handleEnd, false);     function handleStart(ev) &#123;       const touch = ev.changedTouches[0];       // 记录每次按下屏幕的坐标       startPoint.x = touch.pageX;       startPoint.y = touch.pageY;       // console.log(startPoint.x);     &#125;     function handleMove(ev) &#123;       const touch = ev.changedTouches[0];       const diffPoint = &#123;&#125;;       // 保存移动后的坐标点       const movePoint = &#123; x: 0, y: 0 &#125;;       // 计算从按下屏幕到拖动结束移动的距离       // startPoint是每次按下屏幕的坐标       // diffPoint代表每次移动的距离       diffPoint.x = touch.pageX - startPoint.x;       diffPoint.y = touch.pageY - startPoint.y;       // curPoint代表上一次拖拽完成后的坐标，初始为&#123;x: 0, y: 0&#125;       if (options.x) &#123;         movePoint.x = curPoint.x + diffPoint.x;       &#125;       if (options.y) &#123;         movePoint.y = curPoint.y + diffPoint.y;       &#125;\t       // 使用translat3d来改变位置(考虑性能优化，在移动端这条属性会开启GPU加速)       this.style.transform = `translate3d($&#123;movePoint.x&#125;px, $&#123;movePoint.y&#125;px, 0)`;     &#125;     function handleEnd(ev) &#123;       const touch = ev.changedTouches[0];       // 手指离开屏幕，完成了一次拖拽，更新当前坐标位置       // startPoint是每次按下屏幕的坐标       // touch.pageX - startPoint.x代表移动的距离       // curPoint代表上一次拖拽完成后的坐标       // 新的移动后的坐标 = 移动距离 + 初始的坐标       curPoint.x += touch.pageX - startPoint.x;       curPoint.y += touch.pageY - startPoint.y;     &#125;   &#125;// 调用函数，x, y 方向均允许拖拽   drag(backtop, &#123; x: true, y: true &#125;);\n\n\n\n实现效果：\n\n其他触摸事件在现实中，我们用到的往往不是简单的touch，而是一些比较复杂的事件，比如双击、长按屏幕、左右滑动、缩放页面等操作。\n\n想要实现这些复杂的事件，需要使用touch进行封装。\nhammer.min.js已经将这些复杂的操作封装好了，直接下载引用即可。\n一个例子：为一个id为box的div使用hammer.min.js添加事件监听：\n首先需要引入hammer.min.js文件。\n&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/hammer.min.js&quot;&gt;&lt;/script&gt;\n\n然后使用Hammer()函数创建hammer对象，其中传入要绑定的元素。然后使用hammer.on()监听需要监听的事件即可。\nconst box = document.getElementById(&quot;box&quot;);let hammer = new Hammer(box);// swipe: 快速滑动// pan: 拖动// tap: 轻点,类似click,最大点击时间为250ms,超过则按press事件处理// doubletap: 双击// press: 可以理解为长按// pinch: 两个手指（默认为两个手指，多指触控需要单独设置）//        或多个手指相对（越来越近）移动或相向（越来越远）移动时事件// rotate: 当两个手指或更多手指呈圆型旋转时触发hammer.on(&quot;swipe pan tap doubletap press pinch rotate&quot;, function (ev) &#123;  // 输出触发事件对应的名称  console.log(ev.type);&#125;);\n\n","tags":["前端","移动端"]},{"title":"前端——React基础","url":"/2021/03/25/%E5%89%8D%E7%AB%AF-React%E5%9F%BA%E7%A1%80/","content":"React基础什么是组件简单来说，组件就是页面上的一部分。一个页面由多个组件构成。多个组件共同渲染出一个页面。\n\n想让一个组件往页面上渲染内容，需要在这个组件中写一个render()函数\nreact渲染页面的流程：\nindex.html –&gt; 执行index.js –&gt; index.js中引入组件 –&gt; 组件通过render()函数来定义需要渲染的内容 –&gt; 组件在index.js中被引入，使用ReactDom.render()挂载到index.html中\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;    &lt;title&gt;Orla React&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n// index.jsimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;// 引入组件import App from &quot;./App&quot;;import Test from &quot;./Test&quot;;// ReactDom.render在渲染的时候只能渲染单标签ReactDOM.render(  // JSX语法  // 想要渲染多个标签，使用JSX语法，将多个标签放入一个div中即可  &lt;div&gt;    &lt;App /&gt;    &lt;Test /&gt;  &lt;/div&gt;,  // 将App组件的内容挂载到index.html页面id为root的节点上  document.getElementById(&quot;root&quot;));\n\n// App.js 定义App组件import React, &#123; Component &#125; from &quot;react&quot;;// 使用class定义了一个组件// 要往页面上渲染的内容需要写在render()函数中class App extends Component &#123;  render() &#123;    return &lt;div&gt;Hello World&lt;/div&gt;;  &#125;&#125;// function App() &#123;//   return &lt;div&gt;hello world&lt;/div&gt;;// &#125;export default App;\n\n// Test.js 定义Test组件import React, &#123; Component &#125; from &quot;react&quot;;// 使用class定义了一个组件// 要往页面上渲染的内容需要写在render()函数中class Test extends Component &#123;  render() &#123;    return &lt;div&gt;Test组件&lt;/div&gt;;  &#125;&#125;export default Test;\n\n页面效果：\n\nJSX语法React 使用 JSX 来替代常规的 JavaScript。JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。\nJSX语法中，有两种类型的标签：\n\n普通的html标签（div…）\n组件标签（比如上面的&lt;App /&gt;），首字母一定要大写\n\n使用React编写ToDoList下面的代码都是基于TodoList进行编写的。使用代码需要预先创建React项目。可以使用React官方提供的脚手架工具create-react-app快速创建一个React项目（需要nodejs环境）。命令如下：\n$ npx create-react-app my-app$ cd my-app$ npm start$ npm install\n\n如上命令创建了一个名为my-app的项目。使用该项目的目录结构即可。\nTodoList的功能：\n\n输入文字，按下回车，添加对应内容至列表中\n\n点击列表项能够删除该项\n实现效果如下：\n\n\n\n页面结构首先在页面中实现一个静态的input框和ul列表。\n需要注意的是，render一次只能渲染一个外部标签， 想要渲染多个标签，同时不想用div包裹起来导致dom会新增无用的div标签，可以使用React中提供的Fragment标签。\n// index.jsimport React from &quot;react&quot;;import ReactDom from &quot;react-dom&quot;;// 引入组件import TodoList from &quot;./TodoList&quot;;ReactDom.render(&lt;TodoList&gt;&lt;/TodoList&gt;, document.getElementById(&quot;root&quot;));              \n\n// TodoList.js, TodoList组件，组件开头字母大写// 引入Fragment组件import React, &#123; Component, Fragment &#125; from &quot;react&quot;;class TodoList extends Component &#123;  render() &#123;    // render一次只能渲染一个外部标签，想渲染多个，需要将标签放在一个div中。    // 但是这样的做法会导致dom中多出来一个div    // React16中提供了占位符组件Fragment    // 将所有组件放在Fragment中，不会在dom中添加其他的元素    return (      &lt;Fragment&gt;        &lt;input /&gt;        &lt;ul&gt;          &lt;li&gt;Learn React&lt;/li&gt;          &lt;li&gt;Learn Component&lt;/li&gt;        &lt;/ul&gt;      &lt;/Fragment&gt;    );  &#125;&#125;export default TodoList;\n\nReact中数据驱动的设计思想和事件绑定★React是一个数据驱动的框架，所有功能都不直接操作DOM，而是直接操作数据。\nTodoList中的数据分为两部分：input中的数据和ul列表中的数据。需要在代码中把这两种数据定义出来。\n在组件中定义数据，要在render()函数上面写constructor()函数。constructor中接收参数props，并且要调用父类的构造函数，将props传递给父类的构造函数。所以要固定写super函数。\n// 定义组件中的数据constructor(props) &#123;  // 接收参数props，传递给基类(Component)的构造函数  super(props);&#125;\n\n前面提到，TodoList中的数据分为两部分：input中的数据和ul列表中的数据。我们要在constructor函数中，把这两种数据定义出来。\nReact中，定义组建的数据要放在this.state中，以对象的形式进行定义。\nconstructor(props) &#123;    // 接收参数props，传递给基类(Component)的构造函数    super(props);    // React中，定义组件的数据要放在this.state中    // inputValue定义input输入框中的数据    // list定义ul列表中的数据    this.state = &#123;      inputValue: &quot;hello World&quot;,      list: [],    &#125;;  &#125;\n\n定义好数据后，将数据放到要渲染的标签中即可。使用花括号将其包裹起来。\nrender() &#123;  return (    &lt;Fragment&gt;      &#123;/* 使用花括号将数据包裹起来 */&#125;      &lt;input value=&#123;this.state.inputValue&#125; /&gt;      &lt;ul&gt;        &lt;li&gt;Learn React&lt;/li&gt;        &lt;li&gt;Learn Component&lt;/li&gt;      &lt;/ul&gt;    &lt;/Fragment&gt;  );&#125;\n\n页面显示效果如下：\n\n但是这样做会导致一个问题。input框中的value是固定的，在页面中不能修改输入框中的内容。想要能够动态修改框中的内容，需要在input上绑定一个onChange函数（注意和原生js中onchange不同，此处C要大写）\n// 此处这样直接绑定handleInputChange会导致问题，后续会介绍render() &#123;  return (    &lt;Fragment&gt;      &lt;input        value=&#123;this.state.inputValue&#125;        onChange=&#123;this.handleInputChange&#125;      /&gt;      &lt;ul&gt;        &lt;li&gt;Learn React&lt;/li&gt;        &lt;li&gt;Learn Component&lt;/li&gt;      &lt;/ul&gt;    &lt;/Fragment&gt;  );&#125;\n\n在组件对应的类中添加handleInputChange函数\nhandleInputChange(e) &#123;    console.log(e.target.value);  &#125;\n\n这里的e.target指的是这个事件绑定的input元素，e.target.value指的就是input输入框中的内容\n到这里，看起来好像直接修改this.state中inputValue的值就可以了：\nhandleInputChange(e) &#123;  this.state.inputValue = e.target.value;&#125;\n\n不幸的是，输入框中的内容依然不能修改……\nReact中如果想要修改组件中定义的数据，需要使用setState()方法\nhandleInputChange(e) &#123;  // 数据不能直接改变  // this.state.inputValue = e.target.value;  // 要使用setState方法来改变组件中的数据  this.setState(&#123;    inputValue: e.target.value,  &#125;);&#125;\n\n现在setState()也用了，总该没问题了吧。保存！刷新页面！修改输入框中的内容！\n又报错了^_^\n\n呀？他说不能获取undefined的setState……我这个setState可是绑定在this上的……那我看看这个this到底是什么东西。打印一下！\nhandleInputChange(e) &#123;  console.log(this);\t// undefined  this.setState(&#123;    inputValue: e.target.value,  &#125;);&#125;\n\n这个this居然是undefined……\n看一下我们是如何绑定this的\nrender() &#123;  return (    &lt;Fragment&gt;      &lt;input        value=&#123;this.state.inputValue&#125;        onChange=&#123;this.handleInputChange&#125;      /&gt;      &lt;ul&gt;        &lt;li&gt;Learn React&lt;/li&gt;        &lt;li&gt;Learn Component&lt;/li&gt;      &lt;/ul&gt;    &lt;/Fragment&gt;  );&#125;\n\nonChange=&#123;this.handleInputChange&#125;中的this是render函数自身的this，指向组件实例。\n此时this.handleInputChange只是对于handleInputChange的一个引用，没有加()进行调用，所以在onChange事件触发时才会调用handleInputChange()方法。\n此时调用这个方法的应该是全局的window对象，this应该指向window，但是ES6中的class是严格模式，所以这时的this指向的就是undefined。\n想要将this绑定到当前的组件实例上，需要使用bind来改变this的指向。于是修改代码如下：\n  render() &#123;    return (      &lt;Fragment&gt;        &#123;/* 使用花括号将数据包裹起来 */&#125;        &lt;input          value=&#123;this.state.inputValue&#125;          onChange=&#123;this.handleInputChange.bind(this)&#125;        /&gt;        &lt;ul&gt;          &lt;li&gt;Learn React&lt;/li&gt;          &lt;li&gt;Learn Component&lt;/li&gt;        &lt;/ul&gt;      &lt;/Fragment&gt;    );  &#125;&#125;\n\nonChange=&#123;this.handleInputChange.bind(this)&#125;使this指向了当前的组件实例，再修改当前组件中的数据就可以了。\n此时我们就可以随意修改输入框中的数据了~\n\n实现TodoList新增删除功能处理完了输入框的输入问题，现在来解决列表新增删除的问题。\n新增之前我们在组件的state中定义了两种数据：input输入框的输入数据和&lt;ul&gt;列表的数据。现在默认输入框内容为空，list中存放原本写在&lt;li&gt;标签中的数据。页面上展示的列表应该由list中的内容来决定。\nconstructor(props) &#123;    super(props);    this.state = &#123;      inputValue: &quot;&quot;,      list: [&quot;Learn React&quot;, &quot;Learn Component&quot;],    &#125;;  &#125;\n\n现在我们希望根据list中的内容循环显示出&lt;li&gt;标签，把它们渲染到页面上。\n使用ES6中的map()方法对数组进行循环。map()方法接收一个函数作为参数，这个函数可以接收几个值：value（数组每一项的值），index（每一项的索引值）。使用map进行循环，每一次循环都需要return出一个结果。\n对于循环的每一个子项都应该有一个key值，这个key值对于每一个循环都应该是唯一的。添加key值会使react的性能更高。\n  render() &#123;    return (      &lt;Fragment&gt;        &#123;/* 使用花括号将数据包裹起来 */&#125;        &lt;input          value=&#123;this.state.inputValue&#125;          onChange=&#123;this.handleInputChange.bind(this)&#125;        /&gt;        &lt;ul&gt;          &#123;this.state.list.map((value, index) =&gt; &#123;            return &lt;li key=&#123;index&#125;&gt;&#123;value&#125;&lt;/li&gt;;          &#125;)&#125;        &lt;/ul&gt;      &lt;/Fragment&gt;    );  &#125;&#125;\n\n此时list数组中的内容便能循环渲染到页面上了。\n我们现在希望能够动态地添加列表项。当我们在输入框中按下回车时，将输入框中的内容添加到列表项中。为input标签添加onKeyUp事件，当按下enter键时，修改list数组中的数据即可。\nhandleKeyUp(e) &#123;  // 回车键的键盘码是13，按下回车代表输入完毕，添加列表项  // 由于函数handleInputChange,this.state.inputValue的值会随着输入框中内容的改变动态改变  // 获取this.state.inputValue就是获取输入框当前内容  // 添加后自动清空输入框  if (e.keyCode === 13) &#123;    const list = [...this.state.list, this.state.inputValue];    this.setState(&#123;      list: list,      inputValue: &quot;&quot;,    &#125;);  &#125;&#125;\n\n完成！效果如下：\n\n删除现在我们希望点击某一列表项，能够删除该项。思路很简单，给li标签添加onClick事件，绑定删除的函数即可。\n在删除的时候，如何能够知道要删除的是哪一项？我们之前遍历数组的时候使用了map()，map()方法中，对于数组每一项都有一个唯一的索引index，根据index值找到要删除的那一项，然后使用splice()方法即可~\nrender() &#123;  return (    &lt;Fragment&gt;      &lt;input        value=&#123;this.state.inputValue&#125;        onChange=&#123;this.handleInputChange.bind(this)&#125;        onKeyUp=&#123;this.handleKeyUp.bind(this)&#125;      /&gt;      &lt;ul&gt;        &#123;this.state.list.map((value, index) =&gt; &#123;          return (            &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;              &#123;value&#125;            &lt;/li&gt;          );        &#125;)&#125;      &lt;/ul&gt;    &lt;/Fragment&gt;  );&#125;\n\nhandleItemClick(index) &#123;  const list = [...this.state.list];  list.splice(index, 1);  this.setState(&#123;    list,  &#125;);&#125;\n\n更多JSX的语法细节bind(this)的优化在上面的代码中，每次监听事件都要调用bind(this)，这样导致页面中到处都是bind()。而且每次使用bind(this)，都会重新生成一个新的函数，也就是说，每次触发事件，都会生成一个新的函数，这样会导致性能降低。\n解决这个问题，可以将this的绑定放在constructor中\nconstructor(props) &#123;    super(props);    this.handleInputChange = this.handleInputChange.bind(this);    this.handleKeyUp = this.handleKeyUp.bind(this);        this.state = &#123;      inputValue: &quot;&quot;,      list: [&quot;Learn React&quot;, &quot;Learn Component&quot;],    &#125;;  &#125;\n\n这样，监听事件的时候就不需要再调用bind(this)了。\nrender() &#123;  return (    &lt;Fragment&gt;      &lt;input        value=&#123;this.state.inputValue&#125;        onChange=&#123;this.handleInputChange&#125;        onKeyUp=&#123;this.handleKeyUp&#125;      /&gt;      &lt;ul&gt;        &#123;this.state.list.map((value, index) =&gt; &#123;          return (            &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;              &#123;value&#125;            &lt;/li&gt;          );        &#125;)&#125;      &lt;/ul&gt;    &lt;/Fragment&gt;  );&#125;\n\n上面对onChange和onKeyUp进行了优化。对于onClick，因为每次需要传一个参数index进去，所以没有办法进行改写。\nJSX的简化之前我们直接在JSX中对数组进行循环，这样显得有些臃肿，我们可以把这部分提取出来，封装到一个函数中，然后直接在JSX中调用这个函数即可。\n// 封装为函数getListItems() &#123;  return this.state.list.map((value, index) =&gt; &#123;    return (      &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;        &#123;value&#125;      &lt;/li&gt;    );  &#125;);&#125;\n\n完整TodoList代码注意：使用代码需要提前创建React项目。请参考1.3节。\npublic/index.html:\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;    &lt;title&gt;Todo List&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\nsrc/index.js:\n// index.jsimport React from &quot;react&quot;;import ReactDom from &quot;react-dom&quot;;// 引入组件import TodoList from &quot;./TodoList&quot;;ReactDom.render(&lt;TodoList&gt;&lt;/TodoList&gt;, document.getElementById(&quot;root&quot;));\n\nsrc/TodoList.js:\n// TodoList组件，组件开头字母大写// 引入Fragment组件import React, &#123; Component, Fragment &#125; from &quot;react&quot;;class TodoList extends Component &#123;  // 定义组件中的数据  constructor(props) &#123;    // 接收参数props，传递给基类(Component)的构造函数    super(props);    this.handleInputChange = this.handleInputChange.bind(this);    this.handleKeyUp = this.handleKeyUp.bind(this);    // React中，定义组件的数据要放在this.state中    // inputValue定义input输入框中的数据    // list定义ul列表中的数据    this.state = &#123;      inputValue: &quot;&quot;,      list: [],    &#125;;  &#125;  handleInputChange(e) &#123;    // 这个函数的this默认是undefined    // 想要让this指向这个组件，需要在render函数中调用此方法时使用bind(this)    // console.log(e.target.value);    // 数据不能直接改变    // this.state.inputValue = e.target.value;    // 要使用setState方法来改变组件中的数据    // console.log(this);    this.setState(&#123;      inputValue: e.target.value,    &#125;);  &#125;  handleKeyUp(e) &#123;    // 回车键的键盘码是13，按下回车代表输入完毕，添加列表项    // 由于函数handleInputChange,this.state.inputValue的值会随着输入框中内容的改变动态改变    // 获取this.state.inputValue就是获取输入框当前内容    // 添加后自动清空输入框    if (e.keyCode === 13 &amp;&amp; e.target.value.trim() !== &quot;&quot;) &#123;      const list = [...this.state.list, this.state.inputValue.trim()];      this.setState(&#123;        list: list,        inputValue: &quot;&quot;,      &#125;);    &#125;  &#125;  handleItemClick(index) &#123;    const list = [...this.state.list];    list.splice(index, 1);    this.setState(&#123;      list,    &#125;);  &#125;  getListItems() &#123;    return this.state.list.map((value, index) =&gt; &#123;      return (        &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;          &#123;value&#125;        &lt;/li&gt;      );    &#125;);  &#125;  render() &#123;    // render一次只能渲染一个外部标签，想渲染多个，需要将标签放在一个div中。    // 但是这样的做法会导致dom中多出来一个div    // React16中提供了占位符组件Fragment    // 将所有组件放在Fragment中，不会在dom中添加其他的元素    return (      &lt;Fragment&gt;        &#123;/* 使用花括号将数据包裹起来 */&#125;        &lt;input          value=&#123;this.state.inputValue&#125;          onChange=&#123;this.handleInputChange&#125;          onKeyUp=&#123;this.handleKeyUp&#125;        /&gt;        &lt;ul&gt;&#123;this.getListItems()&#125;&lt;/ul&gt;      &lt;/Fragment&gt;    );  &#125;&#125;export default TodoList;\n\n","tags":["前端","React"]}]