[{"title":"前端——React中的PropTypes与DefaultProps","url":"/2021/03/31/%E5%89%8D%E7%AB%AF%E2%80%94%E2%80%94React%E4%B8%AD%E7%9A%84PropTypes%E4%B8%8EDefaultProps/","content":"React中的PropTypes与DefaultPropsPropTypes使用propTypes可以实现子组件属性接收的强校验。即子组件接收的属性的类型应该是固定的，父组件不能随便传值。\n回到之前的子组件TodoItem中。\n想要使用PropTypes，首先要引入PropTypes。\nimport PropTypes from &quot;prop-types&quot;;\n\n在TodoItem中以对象的形式添加属性强校验，添加到文件底部。\n// 属性强校验TodoItem.propTypes = &#123;  // content的类型必须是string类型  content: PropTypes.string,  // index的类型必须是number  index: PropTypes.number,  // delFunction的类型必须是function  delFunction: PropTypes.func,&#125;;\n\n如果传值类型不匹配，控制台会给出警告，警告不会阻止程序继续执行，但是会给出一个明显的提示。将content的类型设为number，会报以下警告。\n\n建议在开发过程中将PropTypes写上，这样一旦在传值过程中，有值传递错误时，会给出一些明显的提示。\n如果某个属性值并没有传值，则不会执行校验，设置PropTypes不会生效。\n如果要求必须给属性传值并且校验类型的话，要使用isRequired\n现在在子组件TodoItem中添加一个test属性，父组件中并没有这个属性。\nimport React, &#123; Component &#125; from &quot;react&quot;;import PropTypes from &quot;prop-types&quot;;class TodoItem extends Component &#123;  constructor(props) &#123;    super(props);    this.handleItemClick = this.handleItemClick.bind(this);  &#125;  handleItemClick() &#123;    const &#123; delFunction, index &#125; = this.props;    delFunction(index);  &#125;  render() &#123;    // 这里添加一个test属性，父组件并未传递这个属性    const &#123; content, test &#125; = this.props;    return (      &lt;li onClick=&#123;this.handleItemClick&#125; key=&#123;this.props.index&#125;&gt;        &#123;content&#125; - &#123;test&#125;      &lt;/li&gt;    );  &#125;&#125;// 属性强校验TodoItem.propTypes = &#123;  content: PropTypes.string,  index: PropTypes.number,  delFunction: PropTypes.func,  // 添加isRequired，要求这个属性值必须传递并且进行校验  test: PropTypes.string.isRequired,&#125;;export default TodoItem;\n\n因为父组件并没有传递test这个属性，所以控制台会报一个警告。\n\nPropTypes除了单一的类型，还可以有其他的写法。比如\nTodoItem.propTypes = &#123;  // content的类型必须是数组，数组中的值应该为string或number类型  content: PropTypes.arrayOf(PropTypes.string, PropTypes.number),&#125;;\n\n其他写法可以详见官网文档\nDefaultProps有时候父组件确实无法给某个属性传值，但是子组件中又要求这个属性必须有值，这时候就需要用到DefaultProps。\n同样要在子组件中以对象的形式进行定义。\n// 属性强校验TodoItem.propTypes = &#123;  content: PropTypes.string,  index: PropTypes.number,  delFunction: PropTypes.func,  // 添加isRequired，要求这个属性值必须传递并且进行校验  test: PropTypes.string.isRequired,&#125;;// 默认值TodoItem.defaultProps = &#123;  test: &quot;hello world&quot;,&#125;;\n\n以上代码表示，父组件需要给子组件传递一个test，类型为string，而且是必填的。如果父组件没有传这个test，则会给test一个默认值，这个默认值为hello world。这时，即使父组件没有向子组件传递test也没有关系，因为我们定义了默认值。\n\n","tags":["前端","React"]},{"title":"ES6（一）let & const","url":"/2021/03/18/ES6%EF%BC%88%E4%B8%80%EF%BC%89let%20&%20const/","content":"ES6 let&amp;const命令let和const是ES6中新增的两个声明变量的命令。\n基本用法和var相同，区别在于let和const声明的变量只在声明的代码块内有效。\nif (true) &#123;    let myName = &quot;Orla&quot;;&#125;console.log(myName);\t\t// Uncaught ReferenceError: myName is not defined\n\nlet代替var来声明变量，const代替var来声明常量。\nvar和let声明的是变量，变量初始化后还可以重新赋值；const声明的常量一旦初始化，就不能重新赋值，否则会报错。（实际上不是常量的值不可以改变，而是指向的内存地址不可以改变，此处针对引用数据类型）\nconst person = &#123;    name: &quot;Orla&quot;,    age: 20,&#125;;person.name = &quot;Zhangsan&quot;;console.log(person);\n\n\n\n\nlet&amp;const与var的区别不存在变量提升var命令存在变量提升现象，即变量可以在声明之前使用，其值为undefined。但这并不符合逻辑。let&amp;const消除了这种现象，变量必须在声明之后才能使用。\nconsole.log(a); // undefinedvar a = 10;console.log(b); // 报错 Uncaught ReferenceError: Cannot access &#x27;b&#x27; before initializationlet b = 20;\n\n\n\n重复声明let/const不允许在相同作用域内重复声明同一个变量。\n暂时性死区(TDZ)只要作用域中存在let/const，它们所声明的变量/常量就自动“绑定”这个区域，不再受到外部作用域的影响。只要在声明语句之前使用let/const声明的变量，就会报错。简言之，使用let/const命令声明变量之前，该变量都是不可用的，这就被称作暂时性死区。\nlet a = 20;function func() &#123;    // let不存在变量提升，let声明的a与该区域绑定，不受外部影响    console.log(a); // Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization    let a = 10;&#125;func();\n\n暂时性死区也意味着typeof不再是一个百分百安全的操作。\n&#123;\ttypeof a; // Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization    let a = [];&#125;\n\n\n\nwindow对象的属性和方法全局作用域中，var声明的变量以及通过function声明的函数，会自动变成window对象的属性和方法。let、const不会。\nvar a = 10;let b = 20;const c = 30;function add() &#123;&#125;console.log(window.a); // 10console.log(window.b); // undefinedconsole.log(window.c); // undefinedconsole.log(window.add === add); // true\n\n\n\n块级作用域以for循环为例。如果使用let，i只在for循环体内有效，在循环体外引用就会报错。\nfor (let i = 0; i &lt; 10; i++) &#123;  // ...&#125;console.log(i);// ReferenceError: i is not defined\n\n如果使用var，则会输出10（因为ES5中没有块级作用域）。\n// 变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i// 每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i// 也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。var a = [];for (var i = 0; i &lt; 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[8](); // 10\n\n\n\n如果使用let，声明的变量仅在块级作用域内有效。\n// 变量i是let声明的，当前的i只在本轮循环有效// 每一次循环的i其实都是一个新的变量// for循环的计数器就很适合用let，不会出现全局变量改变的情况var a = [];for (let i = 0; i &lt; 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[8](); // 8\n\n\n\nfor循环有一个特别之处:循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。\nfor (let i = 0; i &lt; 3; i++) &#123;  let i = &#x27;abc&#x27;;  console.log(i);&#125;// abc// abc// abc\n\n","tags":["ES6"]},{"title":"前端——React中的虚拟DOM","url":"/2021/03/31/%E5%89%8D%E7%AB%AF%E2%80%94%E2%80%94React%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDOM/","content":"React中的虚拟DOM初识虚拟DOM首先思考一个问题。\n在之前的例子中，定义了数据state和render函数中的JSX模板，render函数可以将定义好的数据放进对应的模板之中，并且渲染到页面上。state中的数据改变，页面的显示也会随之改变。\n假设现在没有React，要想实现上述的功能，该怎么办？\n先提出一种思路：\n\n首先要定义好要显示的数据state；\n设定一个JSX模板，来容纳我们要显示数据；\n将数据state和模板相结合，生成真实的DOM，将DOM挂载到页面上来显示；\n此时数据state发生改变；\n将新的数据state和模板相结合，生成新的DOM，来替换原始的DOM，并挂载到页面上。\n\n以上就是最简单的实现React底层逻辑的一个思路。\n但是这样做的话，会有一个致命的缺陷。如果数据state中只稍微改动了一点，比如只去掉了一个p标签，或者甚至只是改动了一个字，就要重新生成一个完整的DOM。\n第一次生成了一个完整的DOM片段，第二次不管数据改动幅度有多大，都要再生成一个完整的DOM片段并且进行替换，无论是生成完整的DOM还是对整个DOM进行替换，这两种操作都十分损耗性能。\n那尝试改良一下，不替换整个DOM，而是哪里修改替换哪里。\n第二种思路，前三步和之前相同，区别在于数据修改后如何修改DOM：\n\n首先要定义好要显示的数据state；\n设定一个JSX模板，来容纳我们要显示数据；\n将数据state和模板相结合，生成真实的DOM，将DOM挂载到页面上来显示；\n此时数据state发生改变；\n将新的数据state和模板相结合，生成新的DOM，此时并不直接替换原有的DOM；\n将新的DOM与原始的DOM进行比对，寻找差异；\n用新的DOM中与原始DOM中不同的元素替换掉原来的元素，其余元素保持不变。\n\n乍一看好像比第一种思路多了很多步骤，但是确实会使性能提升一些。因为替换局部的DOM必定会比替换整个DOM的性能高。\n虽然DOM替换的性能节约了一些，但是新的DOM和原始DOM进行比对又会损耗性能。\n这样我们节约了一点性能，但是又消耗了一点性能，这就导致在性能的提升上并不明显。\n于是，React提出了一种方案——虚拟DOM。\n虚拟DOM的思路如下：\n\n首先要定义好要显示的数据state；\n\n设定一个JSX模板，来容纳我们要显示数据；\n\n将数据和state和模板相结合，生成虚拟DOM（虚拟DOM就是一个JS对象，用它来描述真实DOM）；\n假设此时的虚拟DOM为：\n[&#x27;div&#x27;, &#123;id: &#x27;abc&#x27;&#125;, [&#x27;span&#x27;, &#123;&#125;, &#x27;hello world&#x27;]]\n根据虚拟DOM的结构生成真实的DOM，将DOM挂载到页面上来显示；\n此时对应的真实DOM则为：\n&lt;div id=&quot;abc&quot;&gt;    &lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;\n此时数据state发生变化；\n\n数据state和模板相结合，生成新的虚拟DOM；\n[&#x27;div&#x27;, &#123;id: &#x27;abc&#x27;&#125;, [&#x27;span&#x27;, &#123;&#125;, &#x27;Byebye&#x27;]]\n比较原始虚拟DOM和新的虚拟DOM的区别，找到区别的地方（对应例子中span标签里的内容）；\n\n直接操作DOM，改变相应的内容（Span标签中的内容）。\n\n\n生成虚拟DOM是会耗费一点性能，但是虚拟DOM是一个JS对象，用JS生成一个JS对象的代价极低，反之，用JS生成一个DOM对象代价是很高的。\n所以，修改数据后生成虚拟DOM而不是真实DOM，极大地提升了性能；\n后续使用新的虚拟的DOM和原始虚拟进行对比，本质上比较的是两个JS对象，两个JS对象进行比对，对性能的消耗也是极小的，所以这一步也极大地提升了性能；\n找到差异之后直接操作对应的DOM进行操作，这样一整套流程下来，在性能提升方面有了质的飞跃。\n小结：\n虚拟DOM本质上就是JS对象，使用JS对象的操作来代替真实的DOM的操作，极大地提升了性能。\n深入了解虚拟DOM有了上述的理解之后，回过头来看代码。\n之前的render函数中会return一个JSX模板，里面的标签长得很像html标签：\nrender() &#123;  return (    &lt;div&gt;&#123;this.state.inputValue&#125;&lt;/div&gt;  );&#125;\n\n之前我们可能会认为return语句中的div标签就是一个DOM结点，但实际上这是一个JSX模板。React会把模板和数据相结合，结合完成后，生成的是一个虚拟DOM，有了虚拟DOM之后才会再生成真实DOM。\n那么JSX模板和真实DOM之间的关系就是：首先，JSX模板先会变成虚拟DOM（也就是一个JS对象），然后再被转换成真实的DOM。\nReact中将JSX语法转化为虚拟DOM，使用了React.createElement()方法。\n举例。以下两种写法是等价的。\nrender()&#123;  return &lt;div&gt;content&lt;/div&gt;;&#125;\n\nrender()&#123;  return React.createElement(&#x27;div&#x27;, &#123;&#125;, &#x27;content&#x27;);&#125;\n\nReact.createElement()方法是React中更偏向底层的一个接口。在此不做详细说明。\n虚拟DOM的优点\n性能提升了。DOM的比对变成了JS对象的比对。\n它使得跨端应用得以实现。（React Native）\n\n","tags":["前端","React"]},{"title":"前端——React的生命周期函数","url":"/2021/04/06/%E5%89%8D%E7%AB%AF%E2%80%94%E2%80%94React%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/","content":"React的生命周期函数生命周期函数指的是在某一时刻组件会自动调用执行的函数。\n\n各种生命周期函数Initialization阶段进行数据的设置（state, props），没有用到生命周期函数。\nMounting阶段\ncomponentWillMount: 在组件即将被挂载到页面的时刻自动执行。\nrender: 做页面的挂载。\ncomponentDidMount: 在组件被挂载到页面之后自动执行。\n\nUpdation阶段只在数据发生变化时进入这个阶段。在组件更新的过程中(props或state发生变化)，会涉及一些新的生命周期函数。\nprops和state发生变化时，执行的生命周期函数略有不同（props多了一个componentWillReceiveProps）。\n先来看相同的部分：\n\nshouldComponentUpdate: 组件更新之前会被自动执行。该函数要求返回一个布尔值。true代表需要更新，false代表不更新。\ncomponentWillUpdate: 组件被更新之前自动执行，在shouldComponentUpdate之后被执行。如果shouldComponentUpdate返回true才会执行；如果返回false则不会执行。\nrender\ncomponentDidUpdate: 组件更新完成之后会被执行。\n\n接下来是props改变时独有的生命周期函数componentWillReceiveProps。\n如果一个组件没有接收props参数（比如顶层组件），componentWillReceiveProps这个生命周期函数是不会被执行的。\ncomponentWillReceiveProps: 当一个组件从父组件接收参数，如果这个组件第一次存在于父组件中，不会被执行；如果这个组件之前已经存在于父组件中，才会执行。\nUnmounting阶段componentWillUnmount: 当前组件即将被从页面中剔除的时候会被执行。\n生命周期函数使用场景性能优化当父组件中的数据发生改变，render函数就会执行。父组件的render函数执行，子组件的render函数也会执行。如果父组件的数据改变了，但是并不想让子组件重新渲染，就可以使用生命周期函数来进行性能上的优化。\n利用shouldComponentUpdate\nshouldComponentUpdate(nextProps, nextState) &#123;  // nextProps: 组件更新时，接下来props会变化为什么样  // nextState: 组件更新时，接下来state会变化为什么样  // content是自定义的属性名  if (nextProps.content !== this.props.content) &#123;    return true;  &#125; else &#123;    return false;  &#125;&#125;\n\n发送Ajax请求在componentDidMount中发送Ajax请求。\n如果将Ajax请求放到render中，render函数会在数据改变时执行，这样会多次发送Ajax请求。应该寻找只会执行一次的生命周期函数，在其中发送一次Ajax请求即可。\ncomponentDidMount() &#123;  axios    .get(&quot;/api/todolist&quot;)    .then(() =&gt; &#123;      alert(&quot;success&quot;);    &#125;)    .catch(() =&gt; &#123;      alert(&quot;error&quot;);    &#125;);&#125;\n\n在React中使用Ajax需要安装axios。\nnpm install axios\n\n然后在组件中引入axios\nimport axios from &quot;axios&quot;;\n\n接着便可以发送Ajax请求来获取数据了\n一个示例：\ncomponentDidMount() &#123;  axios    .get(      &quot;https://www.fastmock.site/mock/0775a4a75216a7011e70b328b9dce604/todolist/todolist&quot;    )    .then((res) =&gt; &#123;      this.setState(() =&gt; (&#123; list: [...res.data] &#125;));    &#125;)    .catch(() =&gt; &#123;      alert(&quot;error&quot;);    &#125;);&#125;\n\n","tags":["前端","React"]},{"title":"前端——React虚拟DOM中的diff算法","url":"/2021/04/01/%E5%89%8D%E7%AB%AF%E2%80%94%E2%80%94React%E8%99%9A%E6%8B%9FDOM%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/","content":"虚拟DOM中的diff算法上一篇文章中提到了虚拟DOM的实现思想，可以分为以下7步：\n\n首先要定义好要显示的数据state；\n设定一个JSX模板，来容纳我们要显示数据；\n将数据和state和模板相结合，生成虚拟DOM（虚拟DOM就是一个JS对象，用它来描述真实DOM）；\n根据虚拟DOM的结构生成真实的DOM，将DOM挂载到页面上来显示；\n此时数据state发生变化；\n数据state和模板相结合，生成新的虚拟DOM；\n比较原始虚拟DOM和新的虚拟DOM的区别，找到有区别的地方；\n直接操作DOM，修改数据变动的部分。\n\n现在重点关注一下第7步。\n之前提到，虚拟DOM本质上是一个JS对象。现在要做的事情是两个虚拟DOM的比对，也就是两个JS对象的比对，这时需要思考一下，两个JS对象应该如何进行比对来寻找二者之间的差异？\n在React中，两个虚拟DOM进行比对采用的方式，就是diff算法。\ndiff算法根据上述虚拟DOM的实现思想可以知道，当数据发生变化的时候，虚拟DOM才会去做新的比对。那么什么时候才算数据发生了改变？\n当state或者props改变时，数据就发生了改变。props的改变也是因为父组件的state发生了改变，归根结底，数据发生变化都是因为调用了setState()方法。\n之前的文章中提到过，setState()是异步执行的。之所以异步，是为了提升React底层的性能。\n假设我们在很短的时间内连续调用三次setState()，即连续修改三次数据，React并不会进行三次虚拟DOM的比对，而是将三次setState()合并为一个setState()，只做一次虚拟DOM的比对，然后去更新一次DOM。这样的话，就可以省去两次虚拟DOM的比对带来的性能损耗。这就是setState()设为异步的初衷。\n\ndiff算法可以简单理解为，在对两个虚拟DOM进行比较时找不同的算法。\ndiff算法中有一个很重要的概念：同级比较。\n\n这张图中左边的树代表原始的虚拟DOM，右侧的树代表新生成的虚拟DOM。我们现在要用diff算法来比对这两棵树，找到差异之后去更新真实的DOM。\ndiff算法会怎么进行比对呢？同层比对。\n首先，会比较最顶层的虚拟DOM结点（图中红框部分），看这两个结点是否一致。假设这一层的两个结点一致，再去比较下一层，也就是第二层（图中紫框部分）。\n如果顶层的两个结点不一致，那么React就不会继续往下层比较了。React在发现第一层DOM存在差异之后，会把原始页面上的虚拟DOM对应的所有结点的DOM全部删除，重新生成所有DOM，然后用重新生成的DOM替换原始页面上的DOM。\n这样一来，如果在第一层就发现了差异，那么就会重新渲染整个DOM，这看起来性能比较低。\n事实上也确实如此，但是这样进行同层比对，带来的好处就是，比对的算法非常简单，只需要一层一层做对比即可。算法简单就会使得比对的速度很快，所以，虽然可能会造成DOM上重新渲染的性能浪费，但是会大大减少两个虚拟DOM进行比对的算法的性能消耗。\nkey值的引入\n假设现在有一个数组，数组中包含五个数据。在页面第一次渲染的时候，会把这五个数据映射成五个虚拟DOM结点，生成一个小的虚拟DOM树。\n现在，往数组里增加了一项内容（左图蓝色结点），于是，数据发生了变化，生成一个新的虚拟DOM树，然后将两个虚拟DOM进行比对（分别对应左图中上下两排结点），如果每一个虚拟DOM结点没有一个key值的话，每个结点都没有自己的名字。当我们进行比对的时候，结点和结点之间的关系就很难被确立。\n假如在进行虚拟DOM的比对时，可以给每一个虚拟DOM结点起一个名字，那么比较起来就方便多了（如右图）。虚拟DOM的比对可以根据key值做关联，如果原先DOM结点和新的DOM结点的key值一致，那么这个结点就可以复用。那么，只要把新的虚拟DOM树中和原来虚拟DOM树中key值不相同的结点进行相应的修改就可以了。这样的话，就极大地提高了虚拟DOM比对的性能。\n这样做的话，需要一个前提。原本的虚拟DOM树中的结点，在新的虚拟DOM树中的key值不能改变。所以需要使用一个稳定的值作为key值。不稳定的值，比如数组中的index，如果数组中的某一数据被删除，数据对应的索引值也会发生改变，index就是不稳定的值。\n小结：\nReact中的setState()的性能优化：可以将多次setState()合并为一次setState()，然后进行虚拟DOM的比对。\ndiff算法在比对两个虚拟DOM时采用逐层比对的策略，一旦有差异，下面的层便不会再进行比对，直接废弃掉，用新的虚拟DOM替换掉原先的虚拟DOM即可。\nReact在进行列表循环时引入key值，是为了提高虚拟DOM比对时的性能。key值要保持稳定。不要采用index作为key值。\n","tags":["前端","React"]},{"title":"前端——单行/多行文字溢出省略","url":"/2021/03/23/%E5%89%8D%E7%AB%AF%E2%80%94%E2%80%94%E5%8D%95%E8%A1%8C%E5%A4%9A%E8%A1%8C%E6%96%87%E5%AD%97%E6%BA%A2%E5%87%BA%E7%9C%81%E7%95%A5/","content":"前端——单行/多行文字溢出省略单行文字省略样式代码，添加对应的class即可.text-ellipsis&#123;    overflow: hidden;    text-overflow: ellipsis;    white-space: nowrap;&#125;\n\n示例：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;单行文字溢出省略&lt;/title&gt;    &lt;style&gt;      * &#123;        margin: 0;        padding: 0;      &#125;      .container &#123;        margin: 20px auto;        width: 300px;        border: 1px solid #eee;      &#125;      li &#123;        display: block;        list-style: none;        color: rgb(158, 152, 152);        border-bottom: 1px dashed rgb(158, 152, 152);        margin: 10px;      &#125;      .text-ellipsis &#123;        overflow: hidden;        text-overflow: ellipsis;        white-space: nowrap;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;ul&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n效果：\n多行文字省略样式代码，添加对应的class即可.multiline-ellipsis&#123;    overflow: hidden;    text-overflow: ellipsis;    display: -webkit-box;    /* 设置文字显示行数 */    -webkit-line-clamp: 2;    -webkit-box-orient: vertical;    white-space: normal !important;    word-wrap: break-word;&#125;\n\n示例：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;多行文字溢出省略&lt;/title&gt;    &lt;style&gt;      .container &#123;        width: 300px;        margin: 20px auto;        border: 1px solid rgb(155, 147, 147);      &#125;      .multiline-ellipsis &#123;        overflow: hidden;        text-overflow: ellipsis;        display: -webkit-box;        /* 设置文字显示行数 */        -webkit-line-clamp: 2;        -webkit-box-orient: vertical;        white-space: normal !important;        word-wrap: break-word;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;h3&gt;岳阳楼记&lt;/h3&gt;      &lt;p class=&quot;multiline-ellipsis&quot;&gt;        庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴，乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上，属予作文以记之。&lt;br /&gt;        予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯，朝晖夕阴，气象万千，此则岳阳楼之大观也，前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？&lt;br /&gt;        若夫淫雨霏霏，连月不开，阴风怒号，浊浪排空，日星隐曜，山岳潜形，商旅不行，樯倾楫摧，薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣。&lt;br /&gt;        至若春和景明，波澜不惊，上下天光，一碧万顷，沙鸥翔集，锦鳞游泳，岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧，渔歌互答，此乐何极！登斯楼也，则有心旷神怡，宠辱偕忘，把酒临风，其喜洋洋者矣。&lt;br /&gt;        嗟夫！予尝求古仁人之心，或异二者之为，何哉？不以物喜，不以己悲，居庙堂之高则忧其民，处江湖之远则忧其君。是进亦忧，退亦忧。然则何时而乐耶？其必曰“先天下之忧而忧，后天下之乐而乐”乎！噫！微斯人，吾谁与归？&lt;br /&gt;        时六年九月十五日。      &lt;/p&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n效果：\n","tags":["前端","css"]},{"title":"前端——围绕React衍生出的思考","url":"/2021/03/31/%E5%89%8D%E7%AB%AF%E2%80%94%E2%80%94%E5%9B%B4%E7%BB%95React%E8%A1%8D%E7%94%9F%E5%87%BA%E7%9A%84%E6%80%9D%E8%80%83/","content":"围绕React衍生出的思考声明式开发直接操作DOM的编程方式称为命令式开发，这种开发方式有60%-70%的操作都是在对DOM进行操作。\nReact是声明式开发。React是面向数据编程的，我们只需要把数据构建好，React会自动根据数据来构建网站。这种声明式的开发可以帮助我们节省掉大量DOM操作的代码。\n可以与其他框架并存React编程过程中，可以同时使用其他框架（比如Vue、jQuery等），即可以与其他框架并存。\n组件化开发通过React继承Component来实现一个组件。所有组件首字母均大写。\n组件在整个应用之中是一个树状的结构。\n组件之间的传值，是由父组件通过属性向子组件传值。\n子组件想操作父组件的数据，需要通过父组件向子组件传递一个方法，子组件调用这个方法，间接地操作父组件的数据，从而实现子组件和父组件的通信。\n单向数据流父组件可以向子组件传递内容，但是子组件只能使用父组件传递过来的值，绝不能改变这个值。\n如果允许子组件改变父组件的值，假设页面中有五个子组件使用了父组件中的同一个值，一旦页面出现bug，错误很难被定位，需要在五个子组件中逐个排查。\n视图层框架React是一个视图层的框架。\n在小型项目中，借助React内部的传值机制就可以完成开发，但是大型项目中单单使用React是绝对不够的。组件在整个项目之中是一个树状的结构，如果一颗树中的叶结点想和根结点进行通信，需要层层向下传值，这无疑是很麻烦的。\n在大型项目中，需要一些数据层的框架帮助我们解决层层组件的传值问题。React只负责数据和页面的渲染的一些东西，至于组件之间的传值，交给其他框架来做。比如Redux。\n函数式编程当我们编写React代码的时候，其实编写的都是一个个的函数。\n这样的方式有几个好处。\n首先，维护起来比较容易，当一个函数比较大的时候可以进行拆分，每个函数可以各司其职。\n其次，做前端自动化测试的时候，如果项目中都是由函数组成的，做自动化测试就很容易了，只需要给函数一个输入值，看函数是否能给出一个预期的输出即可。\n","tags":["前端","React"]},{"title":"前端——移动端事件","url":"/2021/03/19/%E5%89%8D%E7%AB%AF%E2%80%94%E2%80%94%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6/","content":"移动端事件移动端事件一共有三类：触摸事件、手势(gesture)事件以及传感器(sensor)事件。其中，触摸事件又可分为touch事件和pointer事件。\n触摸事件touch事件touch分类touch事件可分为touchstart, touchmove, touchend和touchcancel四种。\ntouchstart：手指触摸到屏幕时会触发\ntouchmove：手指按在屏幕上并移动时触发\ntouchend：手指离开屏幕时触发\ntouchcancel：通常是系统级的事件触发。比如正在滑动屏幕时有电话打进来，页面切换到了通话界面，此时就会触发touchcancel事件。\n举个栗子：\n&lt;!-- 页面上存在一个div --&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;\n\n/* 为其设置样式 */#box &#123;  width: 150px;  height: 150px;  background-color: rgb(236, 148, 148);  margin: 20px auto;  color: #fff;  font-weight: bold;  text-align: center;  line-height: 150px;&#125;\n\nconst box = document.getElementById(&quot;box&quot;);// 绑定三个touch事件box.addEventListener(&quot;touchstart&quot;, handleStart, false);box.addEventListener(&quot;touchmove&quot;, handleMove, false);box.addEventListener(&quot;touchend&quot;, handleEnd, false);function handleStart() &#123;  box.innerText = &quot;我被点了&quot;;  console.log(&quot;touchStart&quot;);&#125;function handleMove() &#123;  box.innerText = &quot;正在移动...&quot;;  console.log(&quot;touchMove&quot;);&#125;function handleEnd() &#123;  box.innerText = &quot;松开了！&quot;;  console.log(&quot;touchEnd&quot;);&#125;\n\n当手指在盒子内部点击盒子、移动手指、松开手指时，效果如下：\n\n当手指在盒子外部点击、移动、松开时，不会触发事件，即使手指在这个过程中移动到了盒子上：\n\n当手指在盒子内部点击，并滑出盒子范围后，事件依然会触发：\n\ntouch事件的event对象每个touch事件都会有event对象，每次touch的信息都会包含在event对象中。\n将上面的代码中的event打印出来。\nfunction handleStart(ev) &#123;        box.innerText = &quot;我被点了&quot;;        console.log(&quot;touchStart&quot;, ev);      &#125;      function handleMove(ev) &#123;        box.innerText = &quot;正在移动...&quot;;        console.log(&quot;touchMove&quot;, ev);      &#125;      function handleEnd(ev) &#123;        box.innerText = &quot;松开了！&quot;;        console.log(&quot;touchEnd&quot;, ev);      &#125;\n\n以touchstart中的event为例：\n\n我们这里重点关注三个属性：changedTouches, targetTouches和touches。\n这三个属性几乎包含了我们手指点击屏幕时所有信息。这三个属性其实都是类数组对象，具有下标和length，但是没有数组的方法。\ntouches的length代表触摸屏幕的手指数，有多少根手指触摸屏幕，length就是多少。\ntargetTouches的length代表触摸事件绑定元素的手指数，如果手指落在该绑定元素的范围外，则不计入length。\nchangedTouches的length代表触摸事件绑定元素并移动的手指数。注意：假设只有一根手指点击屏幕。当触发touchend时，代表手指离开屏幕时的事件被触发，此时没有手指触摸屏幕，所以此时的touches和targetTouches的length均为0。但是可以检测到手指离开了屏幕，changedTouches的length为1。\n所以推荐使用changedTouches来获取手指触摸时的信息。防止其他属性获取不到touchend事件的相关信息。\nfunction handleEnd(ev) &#123;        box.innerText = &quot;松开了！&quot;;        console.log(&quot;touchEnd&quot;, ev);        console.log(ev.changedTouches);      &#125;\n\n此时输出的就是我们触摸屏幕时的一些信息，包含触摸点的坐标等。这样我们就可以方便地获取到这些信息。\n\n一个小案例：图标拖拽   const backtop = document.getElementById(&quot;backtop&quot;);   // 存放每次开始移动时的手指坐标   const startPoint = &#123;&#125;;   // 实现拖动的函数drag()   // element是绑定的元素   // options是用户传入的参数，&#123;x: true/false, y: true/false&#125;，代表x和y方向上是否允许移动   function drag(element, options) &#123;     options.x = typeof options.x === undefined ? false : options.x;     options.y = typeof options.y === undefined ? false : options.y;     // x, y方向均不允许移动     if (!options.x &amp;&amp; !options.y) return;     const curPoint = &#123;       x: 0,       y: 0,     &#125;;     // 添加touch事件监听     element.addEventListener(&quot;touchstart&quot;, handleStart, false);     element.addEventListener(&quot;touchmove&quot;, handleMove, false);     element.addEventListener(&quot;touchend&quot;, handleEnd, false);     function handleStart(ev) &#123;       const touch = ev.changedTouches[0];       // 记录每次按下屏幕的坐标       startPoint.x = touch.pageX;       startPoint.y = touch.pageY;       // console.log(startPoint.x);     &#125;     function handleMove(ev) &#123;       const touch = ev.changedTouches[0];       const diffPoint = &#123;&#125;;       // 保存移动后的坐标点       const movePoint = &#123; x: 0, y: 0 &#125;;       // 计算从按下屏幕到拖动结束移动的距离       // startPoint是每次按下屏幕的坐标       // diffPoint代表每次移动的距离       diffPoint.x = touch.pageX - startPoint.x;       diffPoint.y = touch.pageY - startPoint.y;       // curPoint代表上一次拖拽完成后的坐标，初始为&#123;x: 0, y: 0&#125;       if (options.x) &#123;         movePoint.x = curPoint.x + diffPoint.x;       &#125;       if (options.y) &#123;         movePoint.y = curPoint.y + diffPoint.y;       &#125;\t       // 使用translat3d来改变位置(考虑性能优化，在移动端这条属性会开启GPU加速)       this.style.transform = `translate3d($&#123;movePoint.x&#125;px, $&#123;movePoint.y&#125;px, 0)`;     &#125;     function handleEnd(ev) &#123;       const touch = ev.changedTouches[0];       // 手指离开屏幕，完成了一次拖拽，更新当前坐标位置       // startPoint是每次按下屏幕的坐标       // touch.pageX - startPoint.x代表移动的距离       // curPoint代表上一次拖拽完成后的坐标       // 新的移动后的坐标 = 移动距离 + 初始的坐标       curPoint.x += touch.pageX - startPoint.x;       curPoint.y += touch.pageY - startPoint.y;     &#125;   &#125;// 调用函数，x, y 方向均允许拖拽   drag(backtop, &#123; x: true, y: true &#125;);\n\n\n\n实现效果：\n\n其他触摸事件在现实中，我们用到的往往不是简单的touch，而是一些比较复杂的事件，比如双击、长按屏幕、左右滑动、缩放页面等操作。\n\n想要实现这些复杂的事件，需要使用touch进行封装。\nhammer.min.js已经将这些复杂的操作封装好了，直接下载引用即可。\n一个例子：为一个id为box的div使用hammer.min.js添加事件监听：\n首先需要引入hammer.min.js文件。\n&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/hammer.min.js&quot;&gt;&lt;/script&gt;\n\n然后使用Hammer()函数创建hammer对象，其中传入要绑定的元素。然后使用hammer.on()监听需要监听的事件即可。\nconst box = document.getElementById(&quot;box&quot;);let hammer = new Hammer(box);// swipe: 快速滑动// pan: 拖动// tap: 轻点,类似click,最大点击时间为250ms,超过则按press事件处理// doubletap: 双击// press: 可以理解为长按// pinch: 两个手指（默认为两个手指，多指触控需要单独设置）//        或多个手指相对（越来越近）移动或相向（越来越远）移动时事件// rotate: 当两个手指或更多手指呈圆型旋转时触发hammer.on(&quot;swipe pan tap doubletap press pinch rotate&quot;, function (ev) &#123;  // 输出触发事件对应的名称  console.log(ev.type);&#125;);\n\n","tags":["前端","移动端"]},{"title":"前端——React基础","url":"/2021/03/25/%E5%89%8D%E7%AB%AF%E2%80%94%E2%80%94React%E5%9F%BA%E7%A1%80/","content":"React基础什么是组件简单来说，组件就是页面上的一部分。一个页面由多个组件构成。多个组件共同渲染出一个页面。\n\n想让一个组件往页面上渲染内容，需要在这个组件中写一个render()函数\nreact渲染页面的流程：\nindex.html –&gt; 执行index.js –&gt; index.js中引入组件 –&gt; 组件通过render()函数来定义需要渲染的内容 –&gt; 组件在index.js中被引入，使用ReactDom.render()挂载到index.html中\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;    &lt;title&gt;Orla React&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n// index.jsimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;// 引入组件import App from &quot;./App&quot;;import Test from &quot;./Test&quot;;// ReactDom.render在渲染的时候只能渲染单标签ReactDOM.render(  // JSX语法  // 想要渲染多个标签，使用JSX语法，将多个标签放入一个div中即可  &lt;div&gt;    &lt;App /&gt;    &lt;Test /&gt;  &lt;/div&gt;,  // 将App组件的内容挂载到index.html页面id为root的节点上  document.getElementById(&quot;root&quot;));\n\n// App.js 定义App组件import React, &#123; Component &#125; from &quot;react&quot;;// 使用class定义了一个组件// 要往页面上渲染的内容需要写在render()函数中class App extends Component &#123;  render() &#123;    return &lt;div&gt;Hello World&lt;/div&gt;;  &#125;&#125;// function App() &#123;//   return &lt;div&gt;hello world&lt;/div&gt;;// &#125;export default App;\n\n// Test.js 定义Test组件import React, &#123; Component &#125; from &quot;react&quot;;// 使用class定义了一个组件// 要往页面上渲染的内容需要写在render()函数中class Test extends Component &#123;  render() &#123;    return &lt;div&gt;Test组件&lt;/div&gt;;  &#125;&#125;export default Test;\n\n页面效果：\n\nJSX语法React 使用 JSX 来替代常规的 JavaScript。JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。\nJSX语法中，有两种类型的标签：\n\n普通的html标签（div…）\n组件标签（比如上面的&lt;App /&gt;），首字母一定要大写\n\n使用React编写ToDoList下面的代码都是基于TodoList进行编写的。使用代码需要预先创建React项目。可以使用React官方提供的脚手架工具create-react-app快速创建一个React项目（需要nodejs环境）。命令如下：\n$ npx create-react-app my-app$ cd my-app$ npm start$ npm install\n\n如上命令创建了一个名为my-app的项目。使用该项目的目录结构即可。\nTodoList的功能：\n\n输入文字，按下回车，添加对应内容至列表中\n\n点击列表项能够删除该项\n实现效果如下：\n\n\n\n页面结构首先在页面中实现一个静态的input框和ul列表。\n需要注意的是，render一次只能渲染一个外部标签， 想要渲染多个标签，同时不想用div包裹起来导致dom会新增无用的div标签，可以使用React中提供的Fragment标签。\n// index.jsimport React from &quot;react&quot;;import ReactDom from &quot;react-dom&quot;;// 引入组件import TodoList from &quot;./TodoList&quot;;ReactDom.render(&lt;TodoList&gt;&lt;/TodoList&gt;, document.getElementById(&quot;root&quot;));              \n\n// TodoList.js, TodoList组件，组件开头字母大写// 引入Fragment组件import React, &#123; Component, Fragment &#125; from &quot;react&quot;;class TodoList extends Component &#123;  render() &#123;    // render一次只能渲染一个外部标签，想渲染多个，需要将标签放在一个div中。    // 但是这样的做法会导致dom中多出来一个div    // React16中提供了占位符组件Fragment    // 将所有组件放在Fragment中，不会在dom中添加其他的元素    return (      &lt;Fragment&gt;        &lt;input /&gt;        &lt;ul&gt;          &lt;li&gt;Learn React&lt;/li&gt;          &lt;li&gt;Learn Component&lt;/li&gt;        &lt;/ul&gt;      &lt;/Fragment&gt;    );  &#125;&#125;export default TodoList;\n\nReact中数据驱动的设计思想和事件绑定★React是一个数据驱动的框架，所有功能都不直接操作DOM，而是直接操作数据。\nTodoList中的数据分为两部分：input中的数据和ul列表中的数据。需要在代码中把这两种数据定义出来。\n在组件中定义数据，要在render()函数上面写constructor()函数。constructor中接收参数props，并且要调用父类的构造函数，将props传递给父类的构造函数。所以要固定写super函数。\n// 定义组件中的数据constructor(props) &#123;  // 接收参数props，传递给基类(Component)的构造函数  super(props);&#125;\n\n前面提到，TodoList中的数据分为两部分：input中的数据和ul列表中的数据。我们要在constructor函数中，把这两种数据定义出来。\nReact中，定义组件的数据要放在this.state中，以对象的形式进行定义。\nconstructor(props) &#123;    // 接收参数props，传递给基类(Component)的构造函数    super(props);    // React中，定义组件的数据要放在this.state中    // inputValue定义input输入框中的数据    // list定义ul列表中的数据    this.state = &#123;      inputValue: &quot;hello World&quot;,      list: [],    &#125;;  &#125;\n\n定义好数据后，将数据放到要渲染的标签中即可。使用花括号将其包裹起来。\nrender() &#123;  return (    &lt;Fragment&gt;      &#123;/* 使用花括号将数据包裹起来 */&#125;      &lt;input value=&#123;this.state.inputValue&#125; /&gt;      &lt;ul&gt;        &lt;li&gt;Learn React&lt;/li&gt;        &lt;li&gt;Learn Component&lt;/li&gt;      &lt;/ul&gt;    &lt;/Fragment&gt;  );&#125;\n\n页面显示效果如下：\n\n但是这样做会导致一个问题。input框中的value是固定的，在页面中不能修改输入框中的内容。想要能够动态修改框中的内容，需要在input上绑定一个onChange函数（注意和原生js中onchange不同，此处C要大写）\n// 此处这样直接绑定handleInputChange会导致问题，后续会介绍render() &#123;  return (    &lt;Fragment&gt;      &lt;input        value=&#123;this.state.inputValue&#125;        onChange=&#123;this.handleInputChange&#125;      /&gt;      &lt;ul&gt;        &lt;li&gt;Learn React&lt;/li&gt;        &lt;li&gt;Learn Component&lt;/li&gt;      &lt;/ul&gt;    &lt;/Fragment&gt;  );&#125;\n\n在组件对应的类中添加handleInputChange函数\nhandleInputChange(e) &#123;    console.log(e.target.value);  &#125;\n\n这里的e.target指的是这个事件绑定的input元素，e.target.value指的就是input输入框中的内容\n到这里，看起来好像直接修改this.state中inputValue的值就可以了：\nhandleInputChange(e) &#123;  this.state.inputValue = e.target.value;&#125;\n\n不幸的是，输入框中的内容依然不能修改……\nReact中如果想要修改组件中定义的数据，需要使用setState()方法\nhandleInputChange(e) &#123;  // 数据不能直接改变  // this.state.inputValue = e.target.value;  // 要使用setState方法来改变组件中的数据  this.setState(&#123;    inputValue: e.target.value,  &#125;);&#125;\n\n现在setState()也用了，总该没问题了吧。保存！刷新页面！修改输入框中的内容！\n又报错了^_^\n\n呀？他说不能获取undefined的setState……我这个setState可是绑定在this上的……那我看看这个this到底是什么东西。打印一下！\nhandleInputChange(e) &#123;  console.log(this);\t// undefined  this.setState(&#123;    inputValue: e.target.value,  &#125;);&#125;\n\n这个this居然是undefined……\n看一下我们是如何绑定this的\nrender() &#123;  return (    &lt;Fragment&gt;      &lt;input        value=&#123;this.state.inputValue&#125;        onChange=&#123;this.handleInputChange&#125;      /&gt;      &lt;ul&gt;        &lt;li&gt;Learn React&lt;/li&gt;        &lt;li&gt;Learn Component&lt;/li&gt;      &lt;/ul&gt;    &lt;/Fragment&gt;  );&#125;\n\nonChange=&#123;this.handleInputChange&#125;中的this是render函数自身的this，指向组件实例。\n此时this.handleInputChange只是对于handleInputChange的一个引用，没有加()进行调用，所以在onChange事件触发时才会调用handleInputChange()方法。\n此时调用这个方法的应该是全局的window对象，this应该指向window，但是ES6中的class是严格模式，所以这时的this指向的就是undefined。\n想要将this绑定到当前的组件实例上，需要使用bind来改变this的指向。于是修改代码如下：\n  render() &#123;    return (      &lt;Fragment&gt;        &#123;/* 使用花括号将数据包裹起来 */&#125;        &lt;input          value=&#123;this.state.inputValue&#125;          onChange=&#123;this.handleInputChange.bind(this)&#125;        /&gt;        &lt;ul&gt;          &lt;li&gt;Learn React&lt;/li&gt;          &lt;li&gt;Learn Component&lt;/li&gt;        &lt;/ul&gt;      &lt;/Fragment&gt;    );  &#125;&#125;\n\nonChange=&#123;this.handleInputChange.bind(this)&#125;使this指向了当前的组件实例，再修改当前组件中的数据就可以了。\n此时我们就可以随意修改输入框中的数据了~\n\n实现TodoList新增删除功能处理完了输入框的输入问题，现在来解决列表新增删除的问题。\n新增之前我们在组件的state中定义了两种数据：input输入框的输入数据和&lt;ul&gt;列表的数据。现在默认输入框内容为空，list中存放原本写在&lt;li&gt;标签中的数据。页面上展示的列表应该由list中的内容来决定。\nconstructor(props) &#123;    super(props);    this.state = &#123;      inputValue: &quot;&quot;,      list: [&quot;Learn React&quot;, &quot;Learn Component&quot;],    &#125;;  &#125;\n\n现在我们希望根据list中的内容循环显示出&lt;li&gt;标签，把它们渲染到页面上。\n使用ES6中的map()方法对数组进行循环。map()方法接收一个函数作为参数，这个函数可以接收几个值：value（数组每一项的值），index（每一项的索引值）。使用map进行循环，每一次循环都需要return出一个结果。\n对于循环的每一个子项都应该有一个key值，这个key值对于每一个循环都应该是唯一的。添加key值会使react的性能更高。\n  render() &#123;    return (      &lt;Fragment&gt;        &#123;/* 使用花括号将数据包裹起来 */&#125;        &lt;input          value=&#123;this.state.inputValue&#125;          onChange=&#123;this.handleInputChange.bind(this)&#125;        /&gt;        &lt;ul&gt;          &#123;this.state.list.map((value, index) =&gt; &#123;            return &lt;li key=&#123;index&#125;&gt;&#123;value&#125;&lt;/li&gt;;          &#125;)&#125;        &lt;/ul&gt;      &lt;/Fragment&gt;    );  &#125;&#125;\n\n此时list数组中的内容便能循环渲染到页面上了。\n我们现在希望能够动态地添加列表项。当我们在输入框中按下回车时，将输入框中的内容添加到列表项中。为input标签添加onKeyUp事件，当按下enter键时，修改list数组中的数据即可。\nhandleKeyUp(e) &#123;  // 回车键的键盘码是13，按下回车代表输入完毕，添加列表项  // 由于函数handleInputChange,this.state.inputValue的值会随着输入框中内容的改变动态改变  // 获取this.state.inputValue就是获取输入框当前内容  // 添加后自动清空输入框  if (e.keyCode === 13) &#123;    const list = [...this.state.list, this.state.inputValue];    this.setState(&#123;      list: list,      inputValue: &quot;&quot;,    &#125;);  &#125;&#125;\n\n完成！效果如下：\n\n删除现在我们希望点击某一列表项，能够删除该项。思路很简单，给li标签添加onClick事件，绑定删除的函数即可。\n在删除的时候，如何能够知道要删除的是哪一项？我们之前遍历数组的时候使用了map()，map()方法中，对于数组每一项都有一个唯一的索引index，根据index值找到要删除的那一项，然后使用splice()方法即可~\nrender() &#123;  return (    &lt;Fragment&gt;      &lt;input        value=&#123;this.state.inputValue&#125;        onChange=&#123;this.handleInputChange.bind(this)&#125;        onKeyUp=&#123;this.handleKeyUp.bind(this)&#125;      /&gt;      &lt;ul&gt;        &#123;this.state.list.map((value, index) =&gt; &#123;          return (            &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;              &#123;value&#125;            &lt;/li&gt;          );        &#125;)&#125;      &lt;/ul&gt;    &lt;/Fragment&gt;  );&#125;\n\nhandleItemClick(index) &#123;  const list = [...this.state.list];  list.splice(index, 1);  this.setState(&#123;    list,  &#125;);&#125;\n\n更多JSX的语法细节bind(this)的优化在上面的代码中，每次监听事件都要调用bind(this)，这样导致页面中到处都是bind()。而且每次使用bind(this)，都会重新生成一个新的函数，也就是说，每次触发事件，都会生成一个新的函数，这样会导致性能降低。\n解决这个问题，可以将this的绑定放在constructor中\nconstructor(props) &#123;    super(props);    this.handleInputChange = this.handleInputChange.bind(this);    this.handleKeyUp = this.handleKeyUp.bind(this);        this.state = &#123;      inputValue: &quot;&quot;,      list: [&quot;Learn React&quot;, &quot;Learn Component&quot;],    &#125;;  &#125;\n\n这样，监听事件的时候就不需要再调用bind(this)了。\nrender() &#123;  return (    &lt;Fragment&gt;      &lt;input        value=&#123;this.state.inputValue&#125;        onChange=&#123;this.handleInputChange&#125;        onKeyUp=&#123;this.handleKeyUp&#125;      /&gt;      &lt;ul&gt;        &#123;this.state.list.map((value, index) =&gt; &#123;          return (            &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;              &#123;value&#125;            &lt;/li&gt;          );        &#125;)&#125;      &lt;/ul&gt;    &lt;/Fragment&gt;  );&#125;\n\n上面对onChange和onKeyUp进行了优化。对于onClick，因为每次需要传一个参数index进去，所以没有办法进行改写。\nJSX的简化之前我们直接在JSX中对数组进行循环，这样显得有些臃肿，我们可以把这部分提取出来，封装到一个函数中，然后直接在JSX中调用这个函数即可。\n// 封装为函数getListItems() &#123;  return this.state.list.map((value, index) =&gt; &#123;    return (      &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;        &#123;value&#125;      &lt;/li&gt;    );  &#125;);&#125;\n\n完整TodoList代码注意：使用代码需要提前创建React项目。请参考1.3节。\npublic/index.html:\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;    &lt;title&gt;Todo List&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\nsrc/index.js:\n// index.jsimport React from &quot;react&quot;;import ReactDom from &quot;react-dom&quot;;// 引入组件import TodoList from &quot;./TodoList&quot;;ReactDom.render(&lt;TodoList&gt;&lt;/TodoList&gt;, document.getElementById(&quot;root&quot;));\n\nsrc/TodoList.js:\n// TodoList组件，组件开头字母大写// 引入Fragment组件import React, &#123; Component, Fragment &#125; from &quot;react&quot;;class TodoList extends Component &#123;  // 定义组件中的数据  constructor(props) &#123;    // 接收参数props，传递给基类(Component)的构造函数    super(props);    this.handleInputChange = this.handleInputChange.bind(this);    this.handleKeyUp = this.handleKeyUp.bind(this);    // React中，定义组件的数据要放在this.state中    // inputValue定义input输入框中的数据    // list定义ul列表中的数据    this.state = &#123;      inputValue: &quot;&quot;,      list: [],    &#125;;  &#125;  handleInputChange(e) &#123;    // 这个函数的this默认是undefined    // 想要让this指向这个组件，需要在render函数中调用此方法时使用bind(this)    // console.log(e.target.value);    // 数据不能直接改变    // this.state.inputValue = e.target.value;    // 要使用setState方法来改变组件中的数据    // console.log(this);    this.setState(&#123;      inputValue: e.target.value,    &#125;);  &#125;  handleKeyUp(e) &#123;    // 回车键的键盘码是13，按下回车代表输入完毕，添加列表项    // 由于函数handleInputChange,this.state.inputValue的值会随着输入框中内容的改变动态改变    // 获取this.state.inputValue就是获取输入框当前内容    // 添加后自动清空输入框    if (e.keyCode === 13 &amp;&amp; e.target.value.trim() !== &quot;&quot;) &#123;      const list = [...this.state.list, this.state.inputValue.trim()];      this.setState(&#123;        list: list,        inputValue: &quot;&quot;,      &#125;);    &#125;  &#125;  handleItemClick(index) &#123;    const list = [...this.state.list];    list.splice(index, 1);    this.setState(&#123;      list,    &#125;);  &#125;  getListItems() &#123;    return this.state.list.map((value, index) =&gt; &#123;      return (        &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;          &#123;value&#125;        &lt;/li&gt;      );    &#125;);  &#125;  render() &#123;    // render一次只能渲染一个外部标签，想渲染多个，需要将标签放在一个div中。    // 但是这样的做法会导致dom中多出来一个div    // React16中提供了占位符组件Fragment    // 将所有组件放在Fragment中，不会在dom中添加其他的元素    return (      &lt;Fragment&gt;        &#123;/* 使用花括号将数据包裹起来 */&#125;        &lt;input          value=&#123;this.state.inputValue&#125;          onChange=&#123;this.handleInputChange&#125;          onKeyUp=&#123;this.handleKeyUp&#125;        /&gt;        &lt;ul&gt;&#123;this.getListItems()&#125;&lt;/ul&gt;      &lt;/Fragment&gt;    );  &#125;&#125;export default TodoList;\n\n","tags":["前端","React"]},{"title":"前端——React组件与生命周期","url":"/2021/03/26/%E5%89%8D%E7%AB%AF%E2%80%94%E2%80%94React%E7%BB%84%E4%BB%B6%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"React组件与声明周期本节代码在前端——React基础基础上进行修改\n组件拆分与组件之间的传值·为什么要拆分组件：提高可维护性\n实践：将list中的item拆分出去，变成更小的组件\n当前getListItems()方法返回的是&lt;li&gt;标签，我们现在要做的是把返回的内容拆分为一个更小的组件。\n只需要将其中的代码重新写到TodoItem.js中，然后在TodoList.js中引入这个组件，以标签的形式使用这个组件即可。\n// TodoItem组件 TodoItem.jsimport React, &#123; Component &#125; from &quot;react&quot;;class TodoItem extends Component &#123;  render() &#123;    return &lt;li&gt;this is an item&lt;/li&gt;;  &#125;&#125;export default TodoItem;\n\n但是我们需要让TodoItem这个组件获取到我们要渲染的数据。此时我们需要找到TodoItem的父级组件，让这个父级组件告诉TodoItem，需要渲染的是什么内容。\n此时，需要使用属性的形式，来告诉子组件需要展示什么内容。\n在父组件引用的子组件标签中，可以任意命名一个属性，通过这个属性的值来给子组件传递一些内容。\n子组件需要使用this.props.属性名来接收父组件传递过来的值。\ngetListItems() &#123;  return this.state.list.map((value, index) =&gt; &#123;    // 此处属性名为content，向子组件TodoItem传递value这个值    return &lt;TodoItem content=&#123;value&#125;&gt;&lt;/TodoItem&gt;;  &#125;);&#125;\n\n// TodoItem组件 TodoItem.jsimport React, &#123; Component &#125; from &quot;react&quot;;class TodoItem extends Component &#123;  render() &#123;    // 使用this.props接收父组件传递过来的内容，属性名为content    return &lt;li&gt;&#123;this.props.content&#125;&lt;/li&gt;;  &#125;&#125;export default TodoItem;\n\n小结：\n父子组件的概念：在一个组件中引用了另一个组件，这两个组件就构成了父子关系。\n父组件通过属性的形式向子组件传值。\n子组件通过this.props的属性，从父组件接收传递过来的值。\n现在继续来拆分。\n拆分出上面的TodoItem组件后，产生了一个问题。我们现在点击列表项无法删除这个列表项了。因为此时组件内的&lt;li&gt;标签上并没有绑定onClick事件。\n此时要注意，我们不能往子组件标签上绑定onClick事件，也就是不能往&lt;TodoItem&gt;标签上绑定事件。我们需要做的是进入到子组件里面，对里面的&lt;li&gt;标签进行事件绑定。\nreturn &lt;li onClick=&#123;this.handleItemClick.bind(this)&#125;&gt;&#123;this.props.content&#125;&lt;/li&gt;;\n\n新的问题又来了。我们要调用的handleItemClick()方法，需要修改的是父组件中的this.state.list的数据。\nReact中父组件除了可以以属性的形式向子组件传递数据，还可以以属性的形式向子组件传递方法。\n此时我们把父组件中的handleItemClick()方法传递给子组件。delFunction=&#123;this.handleItemClick&#125;代表在创建TodoItem子组件时，将handleItemClick方法一同传递给子组件。子组件要做的就是调用这个传递过来的delFunction方法。\n子组件调用父组件传递过来的方法，同样使用this.props进行调用。使用this.props.delFunction()即可。\n// TodoList.js// 为子组件添加传递的方法delFunction  getListItems() &#123;    return this.state.list.map((value, index) =&gt; &#123;      return (        &lt;TodoItem          content=&#123;value&#125;          key=&#123;index&#125;          delFunction=&#123;this.handleItemClick&#125;        &gt;&lt;/TodoItem&gt;      );    &#125;);  &#125;\n\n// TodoItem组件 TodoItem.jsimport React, &#123; Component &#125; from &quot;react&quot;;class TodoItem extends Component &#123;  constructor(props) &#123;    super(props);    this.handleItemClick = this.handleItemClick.bind(this);  &#125;  handleItemClick(e) &#123;    // 改变父组件中的list数据    this.props.delFunction();  &#125;  render() &#123;    return &lt;li onClick=&#123;this.handleItemClick&#125;&gt;&#123;this.props.content&#125;&lt;/li&gt;;  &#125;&#125;export default TodoItem;\n\n如果只是这样写，会报错。因为此时调用的delFunction中，需要修改的是this.state.list的数据，而在子组件中执行，this指向的是当前类的实例，在当前组件中并不存在state.list，所以会报错。\n为了解决这个问题，我们需要在父组件中绑定this为父组件实例，添加this.handleItemClick = this.handleItemClick.bind(this);\n// TodoList的构造函数constructor(props) &#123;  super(props);  this.handleInputChange = this.handleInputChange.bind(this);  this.handleKeyUp = this.handleKeyUp.bind(this);  this.handleItemClick = this.handleItemClick.bind(this);    this.state = &#123;    inputValue: &quot;&quot;,    list: [],  &#125;;&#125;\n\n\n\n但是，删除某一列表项需要获取到该项的index值，我们之前定义的handleItemClick()方法中也确实传入了一个index参数。\n// 之前定义的handleItemClick  handleItemClick(index) &#123;    const list = [...this.state.list];    list.splice(index, 1);    this.setState(&#123;      list,    &#125;);  &#125;\n\n所以在子组件中，需要获取到每项的index值。我们在父组件中遍历数组并且创建TodoItem组件的时候，就可以通过属性的方式把index传递给子组件。（index=&#123;index&#125;）\n// TodoList.js  getListItems() &#123;  return this.state.list.map((value, index) =&gt; &#123;    //   return (    //     &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;    //       &#123;value&#125;    //     &lt;/li&gt;    //   );    // 此处属性名为content，向子组件TodoItem传递value这个值    return (      &lt;TodoItem        content=&#123;value&#125;        key=&#123;index&#125;        index=&#123;index&#125;        delFunction=&#123;this.handleItemClick&#125;      &gt;&lt;/TodoItem&gt;    );  &#125;);&#125;\n\n子组件通过this.props.index就可以获取到index属性值了~\n// TodoItem组件 TodoItem.jsimport React, &#123; Component &#125; from &quot;react&quot;;class TodoItem extends Component &#123;  constructor(props) &#123;    super(props);    this.handleItemClick = this.handleItemClick.bind(this);  &#125;  handleItemClick(e) &#123;    // 改变父组件中的list数据，获取到父组件传递的index值    this.props.delFunction(this.props.index);  &#125;  render() &#123;    return &lt;li onClick=&#123;this.handleItemClick&#125;&gt;&#123;this.props.content&#125;&lt;/li&gt;;  &#125;&#125;export default TodoItem;\n\n★★★小结：\n父组件通过属性形式和子组件进行通信，可以传递值/方法；\n子组件和父组件进行通信，需要调用父组件传递过来的方法。；\n子组件调用父组件的方法时，要在父组件传递方法的过程中，变更方法的作用域，this绑定在父组件中，否则传递到子组件后，this的指向会出现问题。\n拆分组件后的完整代码目录结构如下图所示：\n\npublic/index.html\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;    &lt;title&gt;Orla React&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\nsrc/index.js\n// index.jsimport React from &quot;react&quot;;import ReactDom from &quot;react-dom&quot;;// 引入组件import TodoList from &quot;./TodoList&quot;;ReactDom.render(&lt;TodoList&gt;&lt;/TodoList&gt;, document.getElementById(&quot;root&quot;));\n\nsrc/TodoList.js\n// TodoList组件，组件开头字母大写// 引入Fragment组件import React, &#123; Component, Fragment &#125; from &quot;react&quot;;import TodoItem from &quot;./TodoItem&quot;;class TodoList extends Component &#123;  // 定义组件中的数据  constructor(props) &#123;    // 接收参数props，传递给基类(Component)的构造函数    super(props);    this.handleInputChange = this.handleInputChange.bind(this);    this.handleKeyUp = this.handleKeyUp.bind(this);    this.handleItemClick = this.handleItemClick.bind(this);    // React中，定义组件的数据要放在this.state中    // inputValue定义input输入框中的数据    // list定义ul列表中的数据    this.state = &#123;      inputValue: &quot;&quot;,      list: [],    &#125;;  &#125;  handleInputChange(e) &#123;    // 这个函数的this默认是undefined    // 想要让this指向这个组件，需要在render函数中调用此方法时使用bind(this)    // console.log(e.target.value);    // 数据不能直接改变    // this.state.inputValue = e.target.value;    // 要使用setState方法来改变组件中的数据    // console.log(this);    this.setState(&#123;      inputValue: e.target.value,    &#125;);  &#125;  handleKeyUp(e) &#123;    // 回车键的键盘码是13，按下回车代表输入完毕，添加列表项    // 由于函数handleInputChange,this.state.inputValue的值会随着输入框中内容的改变动态改变    // 获取this.state.inputValue就是获取输入框当前内容    // 添加后自动清空输入框    if (e.keyCode === 13 &amp;&amp; e.target.value.trim() !== &quot;&quot;) &#123;      const list = [...this.state.list, this.state.inputValue.trim()];      this.setState(&#123;        list: list,        inputValue: &quot;&quot;,      &#125;);    &#125;  &#125;  handleItemClick(index) &#123;    const list = [...this.state.list];    list.splice(index, 1);    this.setState(&#123;      list,    &#125;);  &#125;  getListItems() &#123;    return this.state.list.map((value, index) =&gt; &#123;      //   return (      //     &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;      //       &#123;value&#125;      //     &lt;/li&gt;      //   );      // 此处属性名为content，向子组件TodoItem传递value这个值      return (        &lt;TodoItem          content=&#123;value&#125;          key=&#123;index&#125;          index=&#123;index&#125;          delFunction=&#123;this.handleItemClick&#125;        &gt;&lt;/TodoItem&gt;      );    &#125;);  &#125;  render() &#123;    // render一次只能渲染一个外部标签，想渲染多个，需要将标签放在一个div中。    // 但是这样的做法会导致dom中多出来一个div    // React16中提供了占位符组件Fragment    // 将所有组件放在Fragment中，不会在dom中添加其他的元素    return (      &lt;Fragment&gt;        &#123;/* 使用花括号将数据包裹起来 */&#125;        &lt;input          value=&#123;this.state.inputValue&#125;          onChange=&#123;this.handleInputChange&#125;          onKeyUp=&#123;this.handleKeyUp&#125;        /&gt;        &lt;ul&gt;&#123;this.getListItems()&#125;&lt;/ul&gt;      &lt;/Fragment&gt;    );  &#125;&#125;export default TodoList;\n\nsrc/TodoItem.js\n// TodoItem组件 TodoItem.jsimport React, &#123; Component &#125; from &quot;react&quot;;class TodoItem extends Component &#123;  constructor(props) &#123;    super(props);    this.handleItemClick = this.handleItemClick.bind(this);  &#125;  handleItemClick(e) &#123;    // 改变父组件中的list数据，获取到父组件传递的index值    // ES6解构赋值，简化写法。和this.props.delFunction(this.props.index);等价    const &#123; delFunction, index &#125; = this.props;    delFunction(index);  &#125;  render() &#123;    // 使用this.props接收父组件传递过来的内容，属性名为content    // ES6解构赋值简化写法    // const &#123; content &#125; = this.props;    // return &lt;li&gt;&#123;content&#125;&lt;/li&gt;;    return &lt;li onClick=&#123;this.handleItemClick&#125;&gt;&#123;this.props.content&#125;&lt;/li&gt;;  &#125;&#125;export default TodoItem;\n\nReact生命周期React核心特性总结React采用的是声明式开发模式，不需要我们对DOM进行任何操作，只需要定义好JSX模板和数据，数据发生变化时，页面DOM会自动发生变化。从上述TodoList的开发中可见一斑。\nReact可以和其他框架并存。有一套解耦的机制。\n组件化。不用多说了吧，都是组件。\n单向数据流。父组件可以改变子组件的数据，但是子组件一定不能直接改变父组件的数据。\n函数式编程。每个组件都由很多函数构成，方便自动化测试。\nprops, state与render函数props: 属性。父组件通过属性向子组件传递参数。\nstate: 组件中的数据。\nrender函数: 用来渲染组件中的内容。\n这三者之间存在一定的联系：\n当组件初次创建的时候，render函数会被执行一次。\n当state数据发生变更的时候，render函数会被重新执行。\n当props数据发生变更的时候，接收props的子组件的render函数会被重新执行。\n当父组件的render函数被运行时，子组件的render函数都将被重新运行。\n用代码来举例：\n依然是创建一个React项目。页面上显示一个button和一个数字，每当我们点击这个button，数字就会+1。\n\npublic/index.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;    &lt;title&gt;props-state-render&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\nsrc/counter.js\nimport React, &#123; Component &#125; from &quot;react&quot;;class Counter extends Component &#123;  constructor(props) &#123;    super(props);    this.handleClick = this.handleClick.bind(this);    this.state = &#123;      number: 1,    &#125;;  &#125;  handleClick() &#123;    const newNumber = this.state.number + 1;    this.setState(&#123;      number: newNumber,    &#125;);  &#125;  render() &#123;    console.log(&quot;counter render&quot;);    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;点击+1&lt;/button&gt;        &lt;div&gt;&#123;this.state.number&#125;&lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;export default Counter;\n\n在这个组件中，每次调用render函数就会在控制台打印”counter render”。\n来看效果：\n\n从这里可以看出，当组件初次创建的时候，render函数会被执行一次。当state数据发生变更的时候，render函数会被重新执行。\n那么当props改变时，render函数又会如何执行？\n要用props，需要创建一个子组件，并在父组件中引用它。在子组件的render函数中打印”props change”。\nsrc/child.js\n// 子组件child.jsimport React, &#123; Component &#125; from &quot;react&quot;;class Child extends Component &#123;  render() &#123;    // props数据发生改变，子组件的render函数就会重新执行    console.log(&quot;props change&quot;);    return &lt;div&gt;&#123;this.props.number&#125;&lt;/div&gt;;  &#125;&#125;export default Child;\n\nsrc/counter.js\n// 父组件counter.jsimport React, &#123; Component &#125; from &quot;react&quot;;import Child from &quot;./child&quot;;class Counter extends Component &#123;  constructor(props) &#123;    super(props);    this.handleClick = this.handleClick.bind(this);    this.state = &#123;      number: 1,    &#125;;  &#125;  handleClick() &#123;    const newNumber = this.state.number + 1;    this.setState(&#123;      number: newNumber,    &#125;);  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;点击+1&lt;/button&gt;        &lt;Child number=&#123;this.state.number&#125;&gt;&lt;/Child&gt;      &lt;/div&gt;    );  &#125;&#125;export default Counter;\n\n实现效果：\n\n当初次使用子组件时，子组件的render函数会被执行一次。每当props中的数据发生改变时，接收props的子组件的render也会重新执行。\nReact中ref的使用React是一个数据驱动的框架，我们想实现一个功能的时候，不要直接去操作DOM，而是直接操作数据，数据变化，页面就会随之改变。\n但是在某些特殊场景下，我们依然需要对React中某些组件的DOM做一些操作。在React中操作DOM，就需要使用ref。（不推荐使用ref）\n拿上一小节的counter组件举例。现在想实现这样一个功能：当我点击按钮时，我想知道这个按钮距离浏览器顶部的距离是多少。\n思考一下，要想获取到button按钮距离浏览器顶部的距离，那我们就必须获取到button的这个DOM结点，React是数据驱动的，不直接操作DOM，无法帮我们计算距离这样的东西。所以这里需要通过原生的DOM计算来获取到这个距离。\n这时候，ref属性就派上用场了。\n我们可以找到JSX中对应的那个button按钮，在这个按钮上增加一个ref属性，这个属性一般等于一个函数，这个函数接收的参数就是button这个JSX标签真实对应的DOM。将这个参数赋值给当前组建的this之中。我们通过this就可以直接拿到这个DOM结点了。\n看代码：\n// counter.jsimport React, &#123; Component &#125; from &quot;react&quot;;import Child from &quot;./child&quot;;class Counter extends Component &#123;  constructor(props) &#123;    super(props);    this.handleClick = this.handleClick.bind(this);    this.state = &#123;      number: 1,    &#125;;  &#125;  handleClick() &#123;    // 获取button对应的DOM结点    console.log(this.buttonElem);    const newNumber = this.state.number + 1;    this.setState(&#123;      number: newNumber,    &#125;);  &#125;  render() &#123;    // 给button添加ref属性    return (      &lt;div&gt;        &lt;button          onClick=&#123;this.handleClick&#125;          ref=&#123;(button) =&gt; &#123;            this.buttonElem = button;          &#125;&#125;        &gt;          点击+1        &lt;/button&gt;        &lt;Child number=&#123;this.state.number&#125;&gt;&lt;/Child&gt;      &lt;/div&gt;    );  &#125;&#125;export default Counter;\n\n这样通过this.buttonElem我们就拿到了button这个JSX标签真实对应的DOM。\n\n获取到这个DOM结点之后，就可以调用原生属性了~  使用this.buttonElem.clientTop就可以获取到距离顶部的距离。\n现在我们知道了ref的作用：ref可以帮助我们获取JSX标签对应的原生DOM结点\n现在有一个问题。我们把ref放到了标签上可以获取到对应的DOM结点。那如果把ref属性放到组件上呢？\n注意ref中的函数接收参数的名字要和标签相同。\n// counter.js// 给Child组件添加ref属性import React, &#123; Component &#125; from &quot;react&quot;;import Child from &quot;./child&quot;;class Counter extends Component &#123;  constructor(props) &#123;    super(props);    this.handleClick = this.handleClick.bind(this);    this.state = &#123;      number: 1,    &#125;;  &#125;  handleClick() &#123;    // 获取button对应的DOM结点    console.log(this.childElem);    const newNumber = this.state.number + 1;    this.setState(&#123;      number: newNumber,    &#125;);  &#125;  render() &#123;    // 给子组件Child添加ref属性    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;点击+1&lt;/button&gt;        &lt;Child          number=&#123;this.state.number&#125;          ref=&#123;(child) =&gt; &#123;            this.childElem = child;          &#125;&#125;        &gt;&lt;/Child&gt;      &lt;/div&gt;    );  &#125;&#125;export default Counter;\n\n此时打印的是子组件对应的组件实例。\n\n小结：\nref写在JSX的标签上，获取的是对应的DOM结点；\nref写在组件标签上，获取的是组件的js实例。\n异步的setStatesetState有一个很重要的特点：它的执行是异步的。\n举个例子。\n在计数器的基础上，修改代码，显示数字的地方使用div标签，使用ref获取到这个div对应的DOM元素，点击按钮使用setState修改其中的数据。然后在setState之前打印一次div的innerHTML，在setState之后再打印一次div的innerHTML。代码如下：\n// counter.jsimport React, &#123; Component &#125; from &quot;react&quot;;class Counter extends Component &#123;  constructor(props) &#123;    super(props);    this.handleClick = this.handleClick.bind(this);    this.state = &#123;      number: 1,    &#125;;  &#125;  handleClick() &#123;    // setState之前获取div对应的DOM结点中的内容    console.log(this.divElem.innerHTML);    const newNumber = this.state.number + 1;    this.setState(&#123;      number: newNumber,    &#125;);    // setState之后获取div对应的DOM结点中的内容    console.log(this.divElem.innerHTML);  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;点击+1&lt;/button&gt;        &lt;div          ref=&#123;(div) =&gt; &#123;            this.divElem = div;          &#125;&#125;        &gt;          &#123;this.state.number&#125;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;export default Counter;\n\n按理来说，setState之前，number的值并未被修改。初始number值为1，那么最开始应该输出1，调用setState之后，number=number + 1，再次输出number的值应该为2。\n运行一下看看。\n\n两次输出的结果居然一样。\n这里的原因就在于，**setState是异步执行的**。setState还没执行，后面的代码可能就先执行了。\n想解决这个问题，可以将setState换种写法。\n之前我们写setState，都是让其接收一个对象。\nthis.setState(&#123;     number: newNumber,&#125;);\n\n它也可以接收一个函数，在这个函数中return一个对象。这两种写法其实是等价的\nthis.setState(() =&gt; &#123;  return &#123;    number: newNumber,  &#125;;&#125;);\n\n这样写的好处是，我们可以在setState中写第二个参数，第二个参数也是一个函数，这个函数在setState将数据改变之后才会执行。\n修改代码如下。\nimport React, &#123; Component &#125; from &quot;react&quot;;class Counter extends Component &#123;  constructor(props) &#123;    super(props);    this.handleClick = this.handleClick.bind(this);    this.state = &#123;      number: 1,    &#125;;  &#125;  handleClick() &#123;    console.log(this.divElem.innerHTML);    const newNumber = this.state.number + 1;    // 这里修改setState的写法，并传入第二个参数    this.setState(      () =&gt; &#123;        return &#123;          number: newNumber,        &#125;;      &#125;,      () =&gt; &#123;        console.log(this.divElem.innerHTML);      &#125;    );  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;点击+1&lt;/button&gt;        &lt;div          ref=&#123;(div) =&gt; &#123;            this.divElem = div;          &#125;&#125;        &gt;          &#123;this.state.number&#125;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;export default Counter;\n\n这样，第二次输出的就是修改后的number值了。\n\nReact组件的生命周期函数先下个定义：在React中，生命周期函数是组件在某一时刻会自动执行的函数。\n之前使用的render()函数就是一个生命周期函数，它在组件的数据发生变化时自动执行。\n首先来看一下，React组件在展示页面时会分为几个周期。每个周期会有一些生命周期函数自动执行。\n\n① Initialization：组件初始化阶段。设置一些props/state数据。没有用到生命周期函数。\n② Mounting：页面挂载阶段。将数据展示到HTML页面上。三个生命周期函数函数执行顺序：componentWillMount() –&gt; render() –&gt; componentDidMount()，即挂载前准备–&gt;挂载–&gt;挂载完成。只有在组件第一次渲染到页面中时，才会执行Mounting这一阶段。后续修改数据，页面重新渲染，Mounting也不会重新执行。\n③ Updation：数据更新阶段。组件中的数据发生变化，不会重新进行Mounting，而是执行Updation这一阶段。\n​    这一阶段的执行流程分为两类。一类是props发生变化时的执行流程；另一类是states发生变化时的执行流程。\n④ Unmounting：组件销毁阶段。当组件即将从页面中移除时，componentWillUnmount()会自动执行。\n","tags":["前端","React"]}]