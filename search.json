[{"title":"ES6（一）let & const","url":"/2021/03/18/ES6%EF%BC%88%E4%B8%80%EF%BC%89let%20&%20const/","content":"ES6 let&amp;const命令let和const是ES6中新增的两个声明变量的命令。\n基本用法和var相同，区别在于let和const声明的变量只在声明的代码块内有效。\nif (true) &#123;    let myName = &quot;Orla&quot;;&#125;console.log(myName);\t\t// Uncaught ReferenceError: myName is not defined\n\nlet代替var来声明变量，const代替var来声明常量。\nvar和let声明的是变量，变量初始化后还可以重新赋值；const声明的常量一旦初始化，就不能重新赋值，否则会报错。（实际上不是常量的值不可以改变，而是指向的内存地址不可以改变，此处针对引用数据类型）\nconst person = &#123;    name: &quot;Orla&quot;,    age: 20,&#125;;person.name = &quot;Zhangsan&quot;;console.log(person);\n\n\n\n\nlet&amp;const与var的区别不存在变量提升var命令存在变量提升现象，即变量可以在声明之前使用，其值为undefined。但这并不符合逻辑。let&amp;const消除了这种现象，变量必须在声明之后才能使用。\nconsole.log(a); // undefinedvar a = 10;console.log(b); // 报错 Uncaught ReferenceError: Cannot access &#x27;b&#x27; before initializationlet b = 20;\n\n\n\n重复声明let/const不允许在相同作用域内重复声明同一个变量。\n暂时性死区(TDZ)只要作用域中存在let/const，它们所声明的变量/常量就自动“绑定”这个区域，不再受到外部作用域的影响。只要在声明语句之前使用let/const声明的变量，就会报错。简言之，使用let/const命令声明变量之前，该变量都是不可用的，这就被称作暂时性死区。\nlet a = 20;function func() &#123;    // let不存在变量提升，let声明的a与该区域绑定，不受外部影响    console.log(a); // Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization    let a = 10;&#125;func();\n\n暂时性死区也意味着typeof不再是一个百分百安全的操作。\n&#123;\ttypeof a; // Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization    let a = [];&#125;\n\n\n\nwindow对象的属性和方法全局作用域中，var声明的变量以及通过function声明的函数，会自动变成window对象的属性和方法。let、const不会。\nvar a = 10;let b = 20;const c = 30;function add() &#123;&#125;console.log(window.a); // 10console.log(window.b); // undefinedconsole.log(window.c); // undefinedconsole.log(window.add === add); // true\n\n\n\n块级作用域以for循环为例。如果使用let，i只在for循环体内有效，在循环体外引用就会报错。\nfor (let i = 0; i &lt; 10; i++) &#123;  // ...&#125;console.log(i);// ReferenceError: i is not defined\n\n如果使用var，则会输出10（因为ES5中没有块级作用域）。\n// 变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i// 每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i// 也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。var a = [];for (var i = 0; i &lt; 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[8](); // 10\n\n\n\n如果使用let，声明的变量仅在块级作用域内有效。\n// 变量i是let声明的，当前的i只在本轮循环有效// 每一次循环的i其实都是一个新的变量// for循环的计数器就很适合用let，不会出现全局变量改变的情况var a = [];for (let i = 0; i &lt; 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[8](); // 8\n\n\n\nfor循环有一个特别之处:循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。\nfor (let i = 0; i &lt; 3; i++) &#123;  let i = &#x27;abc&#x27;;  console.log(i);&#125;// abc// abc// abc\n\n","tags":["ES6"]},{"title":"前端——移动端事件","url":"/2021/03/19/%E5%89%8D%E7%AB%AF-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6/","content":"移动端事件移动端事件一共有三类：触摸事件、手势(gesture)事件以及传感器(sensor)事件。其中，触摸事件又可分为touch事件和pointer事件。\n触摸事件touch事件touch分类touch事件可分为touchstart, touchmove, touchend和touchcancel四种。\ntouchstart：手指触摸到屏幕时会触发\ntouchmove：手指按在屏幕上并移动时触发\ntouchend：手指离开屏幕时触发\ntouchcancel：通常是系统级的事件触发。比如正在滑动屏幕时有电话打进来，页面切换到了通话界面，此时就会触发touchcancel事件。\n举个栗子：\n&lt;!-- 页面上存在一个div --&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;\n\n/* 为其设置样式 */#box &#123;  width: 150px;  height: 150px;  background-color: rgb(236, 148, 148);  margin: 20px auto;  color: #fff;  font-weight: bold;  text-align: center;  line-height: 150px;&#125;\n\nconst box = document.getElementById(&quot;box&quot;);// 绑定三个touch事件box.addEventListener(&quot;touchstart&quot;, handleStart, false);box.addEventListener(&quot;touchmove&quot;, handleMove, false);box.addEventListener(&quot;touchend&quot;, handleEnd, false);function handleStart() &#123;  box.innerText = &quot;我被点了&quot;;  console.log(&quot;touchStart&quot;);&#125;function handleMove() &#123;  box.innerText = &quot;正在移动...&quot;;  console.log(&quot;touchMove&quot;);&#125;function handleEnd() &#123;  box.innerText = &quot;松开了！&quot;;  console.log(&quot;touchEnd&quot;);&#125;\n\n当手指在盒子内部点击盒子、移动手指、松开手指时，效果如下：\n\n当手指在盒子外部点击、移动、松开时，不会触发事件，即使手指在这个过程中移动到了盒子上：\n\n当手指在盒子内部点击，并滑出盒子范围后，事件依然会触发：\n\ntouch事件的event对象每个touch事件都会有event对象，每次touch的信息都会包含在event对象中。\n将上面的代码中的event打印出来。\nfunction handleStart(ev) &#123;        box.innerText = &quot;我被点了&quot;;        console.log(&quot;touchStart&quot;, ev);      &#125;      function handleMove(ev) &#123;        box.innerText = &quot;正在移动...&quot;;        console.log(&quot;touchMove&quot;, ev);      &#125;      function handleEnd(ev) &#123;        box.innerText = &quot;松开了！&quot;;        console.log(&quot;touchEnd&quot;, ev);      &#125;\n\n以touchstart中的event为例：\n\n我们这里重点关注三个属性：changedTouches, targetTouches和touches。\n这三个属性几乎包含了我们手指点击屏幕时所有信息。这三个属性其实都是类数组对象，具有下标和length，但是没有数组的方法。\ntouches的length代表触摸屏幕的手指数，有多少根手指触摸屏幕，length就是多少。\ntargetTouches的length代表触摸事件绑定元素的手指数，如果手指落在该绑定元素的范围外，则不计入length。\nchangedTouches的length代表触摸事件绑定元素并移动的手指数。注意：假设只有一根手指点击屏幕。当触发touchend时，代表手指离开屏幕时的事件被触发，此时没有手指触摸屏幕，所以此时的touches和targetTouches的length均为0。但是可以检测到手指离开了屏幕，changedTouches的length为1。\n所以推荐使用changedTouches来获取手指触摸时的信息。防止其他属性获取不到touchend事件的相关信息。\nfunction handleEnd(ev) &#123;        box.innerText = &quot;松开了！&quot;;        console.log(&quot;touchEnd&quot;, ev);        console.log(ev.changedTouches);      &#125;\n\n此时输出的就是我们触摸屏幕时的一些信息，包含触摸点的坐标等。这样我们就可以方便地获取到这些信息。\n\n一个小案例：图标拖拽   const backtop = document.getElementById(&quot;backtop&quot;);   // 存放每次开始移动时的手指坐标   const startPoint = &#123;&#125;;   // 实现拖动的函数drag()   // element是绑定的元素   // options是用户传入的参数，&#123;x: true/false, y: true/false&#125;，代表x和y方向上是否允许移动   function drag(element, options) &#123;     options.x = typeof options.x === undefined ? false : options.x;     options.y = typeof options.y === undefined ? false : options.y;     // x, y方向均不允许移动     if (!options.x &amp;&amp; !options.y) return;     const curPoint = &#123;       x: 0,       y: 0,     &#125;;     // 添加touch事件监听     element.addEventListener(&quot;touchstart&quot;, handleStart, false);     element.addEventListener(&quot;touchmove&quot;, handleMove, false);     element.addEventListener(&quot;touchend&quot;, handleEnd, false);     function handleStart(ev) &#123;       const touch = ev.changedTouches[0];       // 记录每次按下屏幕的坐标       startPoint.x = touch.pageX;       startPoint.y = touch.pageY;       // console.log(startPoint.x);     &#125;     function handleMove(ev) &#123;       const touch = ev.changedTouches[0];       const diffPoint = &#123;&#125;;       // 保存移动后的坐标点       const movePoint = &#123; x: 0, y: 0 &#125;;       // 计算从按下屏幕到拖动结束移动的距离       // startPoint是每次按下屏幕的坐标       // diffPoint代表每次移动的距离       diffPoint.x = touch.pageX - startPoint.x;       diffPoint.y = touch.pageY - startPoint.y;       // curPoint代表上一次拖拽完成后的坐标，初始为&#123;x: 0, y: 0&#125;       if (options.x) &#123;         movePoint.x = curPoint.x + diffPoint.x;       &#125;       if (options.y) &#123;         movePoint.y = curPoint.y + diffPoint.y;       &#125;\t       // 使用translat3d来改变位置(考虑性能优化，在移动端这条属性会开启GPU加速)       this.style.transform = `translate3d($&#123;movePoint.x&#125;px, $&#123;movePoint.y&#125;px, 0)`;     &#125;     function handleEnd(ev) &#123;       const touch = ev.changedTouches[0];       // 手指离开屏幕，完成了一次拖拽，更新当前坐标位置       // startPoint是每次按下屏幕的坐标       // touch.pageX - startPoint.x代表移动的距离       // curPoint代表上一次拖拽完成后的坐标       // 新的移动后的坐标 = 移动距离 + 初始的坐标       curPoint.x += touch.pageX - startPoint.x;       curPoint.y += touch.pageY - startPoint.y;     &#125;   &#125;// 调用函数，x, y 方向均允许拖拽   drag(backtop, &#123; x: true, y: true &#125;);\n\n\n\n实现效果：\n\n其他触摸事件在现实中，我们用到的往往不是简单的touch，而是一些比较复杂的事件，比如双击、长按屏幕、左右滑动、缩放页面等操作。\n\n想要实现这些复杂的事件，需要使用touch进行封装。\nhammer.min.js已经将这些复杂的操作封装好了，直接下载引用即可。\n一个例子：为一个id为box的div使用hammer.min.js添加事件监听：\n首先需要引入hammer.min.js文件。\n&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/hammer.min.js&quot;&gt;&lt;/script&gt;\n\n然后使用Hammer()函数创建hammer对象，其中传入要绑定的元素。然后使用hammer.on()监听需要监听的事件即可。\nconst box = document.getElementById(&quot;box&quot;);let hammer = new Hammer(box);// swipe: 快速滑动// pan: 拖动// tap: 轻点,类似click,最大点击时间为250ms,超过则按press事件处理// doubletap: 双击// press: 可以理解为长按// pinch: 两个手指（默认为两个手指，多指触控需要单独设置）//        或多个手指相对（越来越近）移动或相向（越来越远）移动时事件// rotate: 当两个手指或更多手指呈圆型旋转时触发hammer.on(&quot;swipe pan tap doubletap press pinch rotate&quot;, function (ev) &#123;  // 输出触发事件对应的名称  console.log(ev.type);&#125;);\n\n","tags":["前端","移动端"]},{"title":"前端——单行/多行文字溢出省略","url":"/2021/03/23/%E5%89%8D%E7%AB%AF-%E5%8D%95%E8%A1%8C%E5%A4%9A%E8%A1%8C%E6%96%87%E5%AD%97%E6%BA%A2%E5%87%BA%E7%9C%81%E7%95%A5/","content":"前端——单行/多行文字溢出省略单行文字省略样式代码，添加对应的class即可.text-ellipsis&#123;    overflow: hidden;    text-overflow: ellipsis;    white-space: nowrap;&#125;\n\n示例：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;单行文字溢出省略&lt;/title&gt;    &lt;style&gt;      * &#123;        margin: 0;        padding: 0;      &#125;      .container &#123;        margin: 20px auto;        width: 300px;        border: 1px solid #eee;      &#125;      li &#123;        display: block;        list-style: none;        color: rgb(158, 152, 152);        border-bottom: 1px dashed rgb(158, 152, 152);        margin: 10px;      &#125;      .text-ellipsis &#123;        overflow: hidden;        text-overflow: ellipsis;        white-space: nowrap;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;ul&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;        &lt;li class=&quot;text-ellipsis&quot;&gt;          文字文字文字文字文字文字文字文字文字文字文字文字文字文字        &lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n效果：\n多行文字省略样式代码，添加对应的class即可.multiline-ellipsis&#123;    overflow: hidden;    text-overflow: ellipsis;    display: -webkit-box;    /* 设置文字显示行数 */    -webkit-line-clamp: 2;    -webkit-box-orient: vertical;    white-space: normal !important;    word-wrap: break-word;&#125;\n\n示例：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;多行文字溢出省略&lt;/title&gt;    &lt;style&gt;      .container &#123;        width: 300px;        margin: 20px auto;        border: 1px solid rgb(155, 147, 147);      &#125;      .multiline-ellipsis &#123;        overflow: hidden;        text-overflow: ellipsis;        display: -webkit-box;        /* 设置文字显示行数 */        -webkit-line-clamp: 2;        -webkit-box-orient: vertical;        white-space: normal !important;        word-wrap: break-word;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;h3&gt;岳阳楼记&lt;/h3&gt;      &lt;p class=&quot;multiline-ellipsis&quot;&gt;        庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴，乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上，属予作文以记之。&lt;br /&gt;        予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯，朝晖夕阴，气象万千，此则岳阳楼之大观也，前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？&lt;br /&gt;        若夫淫雨霏霏，连月不开，阴风怒号，浊浪排空，日星隐曜，山岳潜形，商旅不行，樯倾楫摧，薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣。&lt;br /&gt;        至若春和景明，波澜不惊，上下天光，一碧万顷，沙鸥翔集，锦鳞游泳，岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧，渔歌互答，此乐何极！登斯楼也，则有心旷神怡，宠辱偕忘，把酒临风，其喜洋洋者矣。&lt;br /&gt;        嗟夫！予尝求古仁人之心，或异二者之为，何哉？不以物喜，不以己悲，居庙堂之高则忧其民，处江湖之远则忧其君。是进亦忧，退亦忧。然则何时而乐耶？其必曰“先天下之忧而忧，后天下之乐而乐”乎！噫！微斯人，吾谁与归？&lt;br /&gt;        时六年九月十五日。      &lt;/p&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n效果：\n","tags":["前端","css"]}]